<section id="screen-pingpong" class="screen">
  <div class="panel">
    <h2>Ping Pong</h2>
    <div class="game-controls">
      <button id="btnPingPongStart" class="chip primary">Start Game</button>
      <button id="btnPingPongPause" class="chip">Pause</button>
      <button id="btnPingPongReset" class="chip">Reset</button>
      <button id="btnHome" class="chip">Home</button>
    </div>
    <div class="ping-pong-container">
      <canvas id="pingPongCanvas"></canvas>
      <div class="ping-pong-score">
        <div class="player-score">
          <span class="score-label">You</span>
          <span class="score-value" id="playerScore">0</span>
        </div>
        <div class="ai-score">
          <span class="score-label">AI</span>
          <span class="score-value" id="aiScore">0</span>
        </div>
      </div>
      <div class="speed-indicator">
        <span class="speed-label">Speed:</span>
        <span class="speed-value" id="speedValue">Normal</span>
      </div>
    </div>
    <div class="game-info">
      <span>First to 11 wins!</span>
      <span>Use ↑↓ arrows or W/S keys to move</span>
    </div>
  </div>
</section>

<style>
  /* Ping Pong App Specific Styles - All scoped to #screen-pingpong */
  #screen-pingpong {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    color: white;
    font-family: 'Arial', sans-serif;
    padding: 20px;
    box-sizing: border-box;
    overflow: hidden;
  }
  
  #screen-pingpong .panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    max-height: 100%;
    overflow: hidden;
  }
  
  #screen-pingpong h2 {
    font-size: clamp(1.5em, 4vw, 2.5em);
    margin: 0;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    text-align: center;
  }
  
  #screen-pingpong .game-controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
    margin: 10px 0;
  }
  
  #screen-pingpong .chip {
    padding: 12px 24px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 25px;
    background: rgba(255,255,255,0.1);
    color: white;
    font-size: clamp(14px, 2.5vw, 16px);
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: inherit;
  }
  
  #screen-pingpong .chip:hover {
    background: rgba(255,255,255,0.2);
    border-color: rgba(255,255,255,0.5);
    transform: translateY(-2px);
  }
  
  #screen-pingpong .chip.primary {
    background: #4CAF50;
    border-color: #4CAF50;
  }
  
  #screen-pingpong .chip.primary:hover {
    background: #45a049;
    transform: translateY(-2px);
  }
  
  #screen-pingpong .ping-pong-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    flex: 1;
    width: 100%;
    max-width: 100%;
  }
  
  #screen-pingpong #pingPongCanvas {
    border: 3px solid rgba(255,255,255,0.3);
    border-radius: 10px;
    background: #000;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
  }
  
  #screen-pingpong .ping-pong-score {
    display: flex;
    gap: 40px;
    background: rgba(255,255,255,0.1);
    padding: 20px;
    border-radius: 15px;
    border: 1px solid rgba(255,255,255,0.2);
  }
  
  #screen-pingpong .player-score,
  #screen-pingpong .ai-score {
    text-align: center;
  }
  
  #screen-pingpong .score-label {
    display: block;
    font-size: clamp(14px, 2.5vw, 16px);
    opacity: 0.8;
    margin-bottom: 8px;
  }
  
  #screen-pingpong .score-value {
    display: block;
    font-size: clamp(24px, 5vw, 32px);
    font-weight: bold;
    color: #4CAF50;
  }
  
  #screen-pingpong .speed-indicator {
    display: flex;
    gap: 10px;
    background: rgba(255,255,255,0.1);
    padding: 10px 20px;
    border-radius: 15px;
    border: 1px solid rgba(255,255,255,0.2);
    align-items: center;
  }
  
  #screen-pingpong .speed-label {
    font-size: clamp(14px, 2.5vw, 16px);
    opacity: 0.8;
  }
  
  #screen-pingpong .speed-value {
    font-size: clamp(14px, 2.5vw, 16px);
    font-weight: bold;
    color: #ff9800;
  }
  
  #screen-pingpong .game-info {
    display: flex;
    flex-direction: column;
    gap: 10px;
    text-align: center;
    font-size: clamp(14px, 2.5vw, 16px);
    opacity: 0.9;
  }
  
  #screen-pingpong .game-info span {
    background: rgba(255,255,255,0.1);
    padding: 8px 16px;
    border-radius: 20px;
    border: 1px solid rgba(255,255,255,0.2);
  }
  
  /* Responsive design */
  @media (max-width: 768px) {
    #screen-pingpong {
      padding: 10px;
    }
    
    #screen-pingpong .game-controls {
      gap: 10px;
    }
    
    #screen-pingpong .chip {
      padding: 10px 20px;
    }
    
    #screen-pingpong .ping-pong-score {
      gap: 20px;
      padding: 15px;
    }
  }
  
  @media (max-height: 600px) {
    #screen-pingpong .panel {
      gap: 10px;
    }
    
    #screen-pingpong h2 {
      font-size: 1.5em;
    }
    
    #screen-pingpong .game-controls {
      margin: 5px 0;
    }
    
    #screen-pingpong .ping-pong-container {
      gap: 10px;
    }
  }
</style>

<script>
  (function() {
    'use strict';
    
    // Game state
    let canvas, ctx;
    let gameLoop = null;
    let isGameRunning = false;
    let isPaused = false;
    
    // Responsive canvas dimensions
    let canvasWidth = 800;
    let canvasHeight = 400;
    let scaleFactor = 1;
    
    // Game objects (will be scaled based on canvas size)
    let ball = { x: 0, y: 0, vx: 0, vy: 0, radius: 8 };
    let playerPaddle = { x: 0, y: 0, width: 10, height: 80, speed: 0 };
    let aiPaddle = { x: 0, y: 0, width: 10, height: 80, speed: 0 };
    
    // Game settings
    const basePaddleSpeed = 5;
    const baseBallSpeed = 4;
    let currentBallSpeed = baseBallSpeed;
    let paddleSpeed = basePaddleSpeed;
    
    // Speed ramping system
    let lastScoreTime = 0;
    let speedRampStartTime = 0;
    const maxSpeedMultiplier = 3.0;
    const speedRampDuration = 30000; // 30 seconds to reach max speed
    
    // Scores
    let playerScore = 0;
    let aiScore = 0;
    
    // Keys state
    let keys = {};
    
    function initApp() {
      console.log('Ping Pong game initialized');
      setupCanvas();
      setupEventListeners();
      loadScores();
      resetGame();
      render();
      
      // Handle window resize
      window.addEventListener('resize', handleResize);
    }
    
    function setupCanvas() {
      canvas = document.querySelector('#pingPongCanvas');
      ctx = canvas.getContext('2d');
      
      calculateCanvasSize();
      setCanvasSize();
    }
    
    function calculateCanvasSize() {
      // Get available space in the container
      const container = document.querySelector('.ping-pong-container');
      const containerRect = container.getBoundingClientRect();
      
      // Calculate maximum available space (accounting for other elements)
      const maxWidth = Math.min(window.innerWidth - 40, containerRect.width);
      const maxHeight = Math.min(window.innerHeight - 200, containerRect.height);
      
      // Maintain aspect ratio (2:1)
      const aspectRatio = 2;
      
      if (maxWidth / aspectRatio <= maxHeight) {
        // Width is the limiting factor
        canvasWidth = maxWidth;
        canvasHeight = maxWidth / aspectRatio;
      } else {
        // Height is the limiting factor
        canvasHeight = maxHeight;
        canvasWidth = maxHeight * aspectRatio;
      }
      
      // Ensure minimum size
      canvasWidth = Math.max(canvasWidth, 400);
      canvasHeight = Math.max(canvasHeight, 200);
      
      // Calculate scale factor based on original 800x400 size
      scaleFactor = canvasWidth / 800;
    }
    
    function setCanvasSize() {
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      
      // Update game object sizes based on scale factor
      ball.radius = 8 * scaleFactor;
      playerPaddle.width = 10 * scaleFactor;
      playerPaddle.height = 80 * scaleFactor;
      aiPaddle.width = 10 * scaleFactor;
      aiPaddle.height = 80 * scaleFactor;
      
      // Update speeds based on scale factor
      paddleSpeed = basePaddleSpeed * scaleFactor;
      currentBallSpeed = baseBallSpeed * scaleFactor;
    }
    
    function handleResize() {
      calculateCanvasSize();
      setCanvasSize();
      resetGame();
      render();
    }
    
    function setupEventListeners() {
      const container = document.querySelector('#screen-pingpong');
      
      // Game control buttons
      container.addEventListener('click', function(e) {
        if (e.target.id === 'btnPingPongStart') {
          if (isGameRunning) {
            stopGame();
          } else {
            startGame();
          }
        } else if (e.target.id === 'btnPingPongPause') {
          togglePause();
        } else if (e.target.id === 'btnPingPongReset') {
          resetGame();
        } else if (e.target.id === 'btnHome') {
          goHome();
        }
      });
      
      // Keyboard controls
      document.addEventListener('keydown', function(e) {
        keys[e.key.toLowerCase()] = true;
      });
      
      document.addEventListener('keyup', function(e) {
        keys[e.key.toLowerCase()] = false;
      });
      
      // Touch controls for mobile
      let touchStartY = 0;
      canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        const touch = e.touches[0];
        touchStartY = touch.clientY;
      });
      
      canvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const deltaY = touch.clientY - touchStartY;
        
        if (deltaY > 10) {
          keys['s'] = true;
          keys['w'] = false;
        } else if (deltaY < -10) {
          keys['w'] = true;
          keys['s'] = false;
        }
      });
      
      canvas.addEventListener('touchend', function(e) {
        e.preventDefault();
        keys['w'] = false;
        keys['s'] = false;
      });
    }
    
    function startGame() {
      if (isGameRunning) return;
      
      isGameRunning = true;
      isPaused = false;
      speedRampStartTime = Date.now();
      document.querySelector('#btnPingPongStart').textContent = 'Stop Game';
      document.querySelector('#btnPingPongStart').classList.add('primary');
      document.querySelector('#btnPingPongPause').textContent = 'Pause';
      
      gameLoop = setInterval(updateGame, 1000 / 60); // 60 FPS
    }
    
    function stopGame() {
      if (!isGameRunning) return;
      
      isGameRunning = false;
      isPaused = false;
      document.querySelector('#btnPingPongStart').textContent = 'Start Game';
      document.querySelector('#btnPingPongStart').classList.remove('primary');
      document.querySelector('#btnPingPongPause').textContent = 'Pause';
      
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
    }
    
    function togglePause() {
      if (!isGameRunning) return;
      
      isPaused = !isPaused;
      document.querySelector('#btnPingPongPause').textContent = isPaused ? 'Resume' : 'Pause';
      
      if (isPaused) {
        if (gameLoop) {
          clearInterval(gameLoop);
          gameLoop = null;
        }
      } else {
        gameLoop = setInterval(updateGame, 1000 / 60);
      }
    }
    
    function resetGame() {
      // Reset ball
      ball.x = canvasWidth / 2;
      ball.y = canvasHeight / 2;
      currentBallSpeed = baseBallSpeed * scaleFactor;
      ball.vx = (Math.random() > 0.5 ? 1 : -1) * currentBallSpeed;
      ball.vy = (Math.random() - 0.5) * currentBallSpeed;
      
      // Reset paddles
      playerPaddle.x = 50 * scaleFactor;
      playerPaddle.y = canvasHeight / 2 - playerPaddle.height / 2;
      aiPaddle.x = canvasWidth - 50 * scaleFactor - aiPaddle.width;
      aiPaddle.y = canvasHeight / 2 - aiPaddle.height / 2;
      
      // Reset scores
      playerScore = 0;
      aiScore = 0;
      updateScores();
      
      // Reset speed ramping
      speedRampStartTime = Date.now();
      updateSpeedIndicator();
      
      // Stop game if running
      if (isGameRunning) {
        stopGame();
      }
    }
    
    function updateSpeedRamp() {
      if (!isGameRunning || isPaused) return;
      
      const currentTime = Date.now();
      const timeSinceStart = currentTime - speedRampStartTime;
      
      // Calculate speed multiplier (1.0 to maxSpeedMultiplier over speedRampDuration)
      const speedMultiplier = 1.0 + (maxSpeedMultiplier - 1.0) * Math.min(timeSinceStart / speedRampDuration, 1.0);
      
      // Update ball speed
      const baseSpeed = baseBallSpeed * scaleFactor;
      currentBallSpeed = baseSpeed * speedMultiplier;
      
      // Update ball velocity magnitude while preserving direction
      const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      if (currentSpeed > 0) {
        const speedRatio = currentBallSpeed / currentSpeed;
        ball.vx *= speedRatio;
        ball.vy *= speedRatio;
      }
      
      updateSpeedIndicator(speedMultiplier);
    }
    
    function updateSpeedIndicator(speedMultiplier = 1.0) {
      const speedElement = document.querySelector('#speedValue');
      let speedText = 'Normal';
      let speedColor = '#ff9800';
      
      if (speedMultiplier >= 2.5) {
        speedText = 'Extreme!';
        speedColor = '#f44336';
      } else if (speedMultiplier >= 2.0) {
        speedText = 'Very Fast';
        speedColor = '#ff5722';
      } else if (speedMultiplier >= 1.5) {
        speedText = 'Fast';
        speedColor = '#ff9800';
      } else if (speedMultiplier >= 1.2) {
        speedText = 'Quick';
        speedColor = '#ffc107';
      }
      
      speedElement.textContent = speedText;
      speedElement.style.color = speedColor;
    }
    
    function updateGame() {
      if (isPaused) return;
      
      // Update speed ramping
      updateSpeedRamp();
      
      // Update player paddle
      if (keys['w'] || keys['arrowup']) {
        playerPaddle.y = Math.max(0, playerPaddle.y - paddleSpeed);
      }
      if (keys['s'] || keys['arrowdown']) {
        playerPaddle.y = Math.min(canvasHeight - playerPaddle.height, playerPaddle.y + paddleSpeed);
      }
      
      // Update AI paddle (simple AI)
      const aiCenter = aiPaddle.y + aiPaddle.height / 2;
      const ballCenter = ball.y;
      
      if (aiCenter < ballCenter - 10) {
        aiPaddle.y = Math.min(canvasHeight - aiPaddle.height, aiPaddle.y + paddleSpeed * 0.8);
      } else if (aiCenter > ballCenter + 10) {
        aiPaddle.y = Math.max(0, aiPaddle.y - paddleSpeed * 0.8);
      }
      
      // Update ball
      ball.x += ball.vx;
      ball.y += ball.vy;
      
      // Ball collision with top and bottom
      if (ball.y <= ball.radius || ball.y >= canvasHeight - ball.radius) {
        ball.vy = -ball.vy;
      }
      
      // Ball collision with paddles
      if (ball.x <= playerPaddle.x + playerPaddle.width + ball.radius &&
          ball.y >= playerPaddle.y && ball.y <= playerPaddle.y + playerPaddle.height &&
          ball.vx < 0) {
        ball.vx = -ball.vx;
        ball.x = playerPaddle.x + playerPaddle.width + ball.radius;
        // Add some randomness to ball direction
        ball.vy += (Math.random() - 0.5) * 2 * scaleFactor;
      }
      
      if (ball.x >= aiPaddle.x - ball.radius &&
          ball.y >= aiPaddle.y && ball.y <= aiPaddle.y + aiPaddle.height &&
          ball.vx > 0) {
        ball.vx = -ball.vx;
        ball.x = aiPaddle.x - ball.radius;
        // Add some randomness to ball direction
        ball.vy += (Math.random() - 0.5) * 2 * scaleFactor;
      }
      
      // Ball out of bounds
      if (ball.x < 0) {
        aiScore++;
        updateScores();
        saveScores();
        if (aiScore >= 11) {
          endGame('ai');
        } else {
          resetBall();
        }
      } else if (ball.x > canvasWidth) {
        playerScore++;
        updateScores();
        saveScores();
        if (playerScore >= 11) {
          endGame('player');
        } else {
          resetBall();
        }
      }
      
      render();
    }
    
    function resetBall() {
      ball.x = canvasWidth / 2;
      ball.y = canvasHeight / 2;
      
      // Reset speed to base and start ramping again
      currentBallSpeed = baseBallSpeed * scaleFactor;
      speedRampStartTime = Date.now();
      
      ball.vx = (Math.random() > 0.5 ? 1 : -1) * currentBallSpeed;
      ball.vy = (Math.random() - 0.5) * currentBallSpeed;
    }
    
    function endGame(winner) {
      stopGame();
      
      if (winner === 'player') {
        alert('Congratulations! You won!');
      } else {
        alert('Game Over! AI wins!');
      }
      
      resetGame();
    }
    
    function render() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // Draw center line
      ctx.strokeStyle = '#fff';
      ctx.setLineDash([5 * scaleFactor, 15 * scaleFactor]);
      ctx.beginPath();
      ctx.moveTo(canvasWidth / 2, 0);
      ctx.lineTo(canvasWidth / 2, canvasHeight);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw ball
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw player paddle
      ctx.fillStyle = '#4CAF50';
      ctx.fillRect(playerPaddle.x, playerPaddle.y, playerPaddle.width, playerPaddle.height);
      
      // Draw AI paddle
      ctx.fillStyle = '#f44336';
      ctx.fillRect(aiPaddle.x, aiPaddle.y, aiPaddle.width, aiPaddle.height);
      
      // Draw scores
      ctx.fillStyle = '#fff';
      ctx.font = `${24 * scaleFactor}px Arial`;
      ctx.textAlign = 'center';
      ctx.fillText(playerScore.toString(), canvasWidth / 4, 50 * scaleFactor);
      ctx.fillText(aiScore.toString(), 3 * canvasWidth / 4, 50 * scaleFactor);
    }
    
    function updateScores() {
      document.querySelector('#playerScore').textContent = playerScore;
      document.querySelector('#aiScore').textContent = aiScore;
    }
    
    function loadScores() {
      try {
        const saved = localStorage.getItem('pingpong-scores');
        if (saved) {
          const scores = JSON.parse(saved);
          playerScore = scores.player || 0;
          aiScore = scores.ai || 0;
          updateScores();
        }
      } catch (e) {
        console.warn('Failed to load scores:', e);
      }
    }
    
    function saveScores() {
      try {
        localStorage.setItem('pingpong-scores', JSON.stringify({
          player: playerScore,
          ai: aiScore
        }));
      } catch (e) {
        console.warn('Failed to save scores:', e);
      }
    }
    
    function goHome() {
      // Direct navigation back to home
      window.location.href = '../index.html';
    }
    
    // Lifecycle management
    window.appLifecycle = {
      activate: function() {
        console.log('Ping Pong game activated');
        // Resume game if it was running
        if (isGameRunning && !isPaused) {
          gameLoop = setInterval(updateGame, 1000 / 60);
        }
      },
      
      deactivate: function() {
        console.log('Ping Pong game deactivated');
        // Pause game when switching away
        if (isGameRunning && !isPaused) {
          if (gameLoop) {
            clearInterval(gameLoop);
            gameLoop = null;
          }
        }
      },
      
      cleanup: function() {
        console.log('Ping Pong game cleanup');
        stopGame();
        // Remove event listeners
        window.removeEventListener('resize', handleResize);
        document.removeEventListener('keydown', function(){});
        document.removeEventListener('keyup', function(){});
      }
    };
    
    // Initialize app
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  })();
</script>
