<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <title>Augmented Reality Demo - RPI Showcase</title>
  
  <!-- Raspberry Pi Camera Detection Script - Simplified -->
  <script>
    // Simple RPi detection
    const isRaspberryPi = () => {
      const userAgent = navigator.userAgent.toLowerCase();
      return userAgent.includes('armv7l') || 
             userAgent.includes('armv6l') || 
             userAgent.includes('aarch64') ||
             (navigator.hardwareConcurrency <= 4 && navigator.deviceMemory <= 4);
    };
    
    window.isRaspberryPi = isRaspberryPi();
    console.log('ü•ß Raspberry Pi detected:', window.isRaspberryPi);
  </script>
  
  <style>
    /* Base styles for AR container */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }
    
    /* AR Scene Container */
    #ar-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    
    /* UI Overlay */
    .ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      pointer-events: none;
    }
    
    /* Top bar with controls */
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      pointer-events: auto;
    }
    
    .logo {
      height: 30px;
      width: auto;
    }
    
    .title {
      font-size: 20px;
      font-weight: 600;
      color: white;
      text-align: center;
      flex: 1;
    }
    
    /* Bottom controls */
    .bottom-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 15px;
      pointer-events: auto;
    }
    
    .control-btn {
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      color: white;
      cursor: pointer;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      font-size: 14px;
      font-weight: 500;
    }
    
    .control-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
      transform: translateY(-2px);
    }
    
    .control-btn.active {
      background: rgba(33, 150, 243, 0.8);
      border-color: #2196f3;
    }
    
    /* Side panel for AR options */
    .side-panel {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0, 0, 0, 0.8);
      border-radius: 15px;
      padding: 20px;
      min-width: 200px;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      pointer-events: auto;
    }
    
    .panel-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #fff;
      text-align: center;
    }
    
    .ar-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      margin: 5px 0;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .ar-option:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .ar-option.active {
      background: rgba(76, 175, 80, 0.6);
      border: 1px solid #4caf50;
    }
    
    .ar-icon {
      width: 20px;
      height: 20px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }
    
    /* Loading screen - simplified */
    .loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      transition: opacity 0.3s ease;
    }
    
    .loading-text {
      margin-top: 20px;
      font-size: 16px;
      color: white;
      text-align: center;
    }
    
    /* AR Status indicator */
    .ar-status {
      position: absolute;
      top: 80px;
      left: 20px;
      padding: 8px 15px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 20px;
      font-size: 12px;
      color: white;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      pointer-events: auto;
    }
    
    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }
    
    .status-dot.camera { background: #4caf50; }
    .status-dot.ar { background: #2196f3; }
    .status-dot.error { background: #f44336; }
    
    /* Error message */
    .error-message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(244, 67, 54, 0.9);
      padding: 20px;
      border-radius: 10px;
      color: white;
      text-align: center;
      max-width: 80%;
      backdrop-filter: blur(10px);
      z-index: 3000;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .top-bar {
        padding: 10px 15px;
      }
      
      .title {
        font-size: 16px;
      }
      
      .side-panel {
        position: fixed;
        bottom: 80px;
        right: 20px;
        left: 20px;
        transform: none;
        top: auto;
      }
      
      .bottom-controls {
        bottom: 10px;
        gap: 10px;
      }
      
      .control-btn {
        padding: 8px 12px;
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <!-- Simple Loading Screen -->
  <div id="loading-screen" class="loading-screen">
    <div class="loading-text">
      <p id="loading-main-text">Starting AR Camera...</p>
    </div>
  </div>

  <!-- Error Message (hidden by default) -->
  <div id="error-message" class="error-message" style="display: none;">
    <h3>ü•ß Raspberry Pi AR Setup Required</h3>
    <p id="error-text">Please allow camera access to use AR features. Refresh the page and try again.</p>
    <div style="margin-top: 15px;">
      <button onclick="retryCamera()" style="margin: 5px; padding: 10px 20px; background: white; color: #f44336; border: none; border-radius: 5px; cursor: pointer;">üîÑ Retry Camera</button>
      <button onclick="goHome()" style="margin: 5px; padding: 10px 20px; background: #2196f3; color: white; border: none; border-radius: 5px; cursor: pointer;">üè† Go Home</button>
    </div>
    <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; font-size: 12px;">
      <strong>ü•ß Raspberry Pi Setup Tips:</strong><br>
      ‚Ä¢ Run <code>sudo raspi-config</code> ‚Üí Interface Options ‚Üí Camera ‚Üí Enable<br>
      ‚Ä¢ Make sure no other apps are using the camera<br>
      ‚Ä¢ Use Chromium browser (pre-installed) for best compatibility<br>
      ‚Ä¢ Ensure you're on local network or HTTPS<br>
      ‚Ä¢ Try rebooting the Pi if camera fails<br>
      ‚Ä¢ Check camera cable connection<br>
      ‚Ä¢ Free up RAM by closing other applications
    </div>
  </div>

  <!-- AR Container -->
  <div id="ar-container">
    <!-- AR Overlay System (simplified) -->
    <div id="ar-overlay" style="
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    ">
      <!-- AR Objects Container -->
      <div id="ar-objects" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: auto;
      ">
        <!-- AR Box -->
        <div id="ar-box" class="ar-object" style="
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 100px;
          height: 100px;
          background: linear-gradient(45deg, #4CC3D9, #2196F3);
          border-radius: 10px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
          opacity: 0;
          transition: all 0.5s ease;
          pointer-events: auto;
          cursor: pointer;
        " onclick="toggleObject('ar-box')">
          <div style="
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
          ">AR Box</div>
        </div>
        
        <!-- AR Sphere -->
        <div id="ar-sphere" class="ar-object" style="
          position: absolute;
          top: 40%;
          left: 30%;
          width: 80px;
          height: 80px;
          background: radial-gradient(circle, #EF2D5E, #C2185B);
          border-radius: 50%;
          box-shadow: 0 6px 24px rgba(0,0,0,0.3);
          opacity: 0;
          transition: all 0.5s ease;
          pointer-events: auto;
          cursor: pointer;
        " onclick="toggleObject('ar-sphere')">
          <div style="
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
          ">AR Sphere</div>
        </div>
        
        <!-- AR Text -->
        <div id="ar-text" class="ar-object" style="
          position: absolute;
          top: 60%;
          left: 70%;
          color: #FFC65D;
          font-size: 24px;
          font-weight: bold;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
          opacity: 0;
          transition: all 0.5s ease;
          pointer-events: auto;
          cursor: pointer;
          text-align: center;
          min-width: 120px;
        " onclick="toggleObject('ar-text')">
          Hello AR!
        </div>
      </div>
      
      <!-- AR Grid Overlay -->
      <div id="ar-grid" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        pointer-events: none;
        z-index: 1;
      ">
        <div style="
          position: absolute;
          top: 50%;
          left: 0;
          right: 0;
          height: 1px;
          background: rgba(255,255,255,0.5);
        "></div>
        <div style="
          position: absolute;
          left: 50%;
          top: 0;
          bottom: 0;
          width: 1px;
          background: rgba(255,255,255,0.5);
        "></div>
      </div>
    </div>

    <!-- UI Overlay -->
    <div class="ui-overlay">
      <!-- Top Bar -->
      <div class="top-bar">
        <img src="../assets/Matrix.png" alt="Matrix TSL" class="logo" />
        <div class="title">Augmented Reality Demo</div>
        <button id="btn-home" class="control-btn" onclick="goHome()">üè† Home</button>
      </div>

      <!-- AR Status -->
      <div class="ar-status">
        <span id="status-indicator" class="status-dot camera"></span>
        <span id="status-text">Camera Active</span>
      </div>

      <!-- Side Panel -->
      <div class="side-panel">
        <div class="panel-title">Interactive AR</div>
        
        <div class="ar-option active" onclick="toggleObject('ar-box')">
          <div class="ar-icon">üì¶</div>
          <span>Interactive Box</span>
        </div>
        
        <div class="ar-option active" onclick="toggleObject('ar-sphere')">
          <div class="ar-icon">üî¥</div>
          <span>Bouncing Sphere</span>
        </div>
        
        <div class="ar-option active" onclick="toggleObject('ar-text')">
          <div class="ar-icon">üìù</div>
          <span>Touch Text</span>
        </div>
        
        <div class="ar-option" onclick="spawnObject('random')">
          <div class="ar-icon">‚ú®</div>
          <span>Spawn Object</span>
        </div>
        
        <div class="ar-option" onclick="changeColors()">
          <div class="ar-icon">üé®</div>
          <span>Change Colors</span>
        </div>
        
        <div class="ar-option" onclick="togglePhysics()">
          <div class="ar-icon">‚ö°</div>
          <span id="physics-toggle">Physics On</span>
        </div>
        
        <div class="ar-option" onclick="captureScreenshot()">
          <div class="ar-icon">üì∏</div>
          <span>Screenshot</span>
        </div>
      </div>

      <!-- Bottom Controls -->
      <div class="bottom-controls">
        <button class="control-btn" onclick="resetScene()">üîÑ Reset</button>
        <button class="control-btn" onclick="toggleCamera()">üìπ Camera</button>
        <button class="control-btn" onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
      </div>
    </div>
  </div>

  <script>
    // AR Application State
    let arScene, camera;
    let isMarkerVisible = false;
    let currentMarker = 'hiro';
    let cameraActive = true;
    let objectStates = {
      'ar-box': true,
      'ar-sphere': true,
      'ar-text': true
    };
    
    // Camera stream for AR
    let cameraStream = null;
    let videoElement = null;
    
    // Interactive AR system
    let arObjects = [];
    let selectedObject = null;
    let isDragging = false;
    let dragStartPos = { x: 0, y: 0 };
    let touchStartDistance = 0;
    let cameraMovement = { x: 0, y: 0 };
    let lastCameraPosition = { x: 0, y: 0 };

    // Initialize AR Application - Direct camera access like camera.html
    document.addEventListener('DOMContentLoaded', function() {
      console.log('üéØ Starting Interactive AR Demo - using direct camera access');
      
      // Initialize camera first, then AR
      initializeCamera();
    });

    // Initialize camera using the same approach as camera.html
    async function initializeCamera() {
      updateLoadingMessage('Starting camera...');
      
      try {
        // Check camera permissions first (if available)
        try {
          const permission = await navigator.permissions.query({ name: 'camera' });
          if (permission.state === 'denied') {
            throw new Error('Camera permission denied');
          }
        } catch (permError) {
          console.log('Permissions API not available, proceeding with camera start');
        }
        
        // Use optimized constraints based on screen size
        const constraints = {
          video: {
            width: { ideal: 640, max: 1280 },
            height: { ideal: 480, max: 720 },
            frameRate: { ideal: 15, max: 30 }
          }
        };

        console.log('üìπ Requesting camera access...');
        cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
        
        // Create video element for AR
        createARVideo();
        
        updateLoadingMessage('Camera active - starting Interactive AR...');
        updateStatus('Camera Active', 'camera');
        
        // Initialize AR after camera is ready
        setTimeout(() => {
          initializeAR();
        }, 1000);
        
      } catch (error) {
        console.error('‚ùå Camera initialization failed:', error);
        
        let errorMessage = 'Camera failed to start. Please check permissions and refresh.';
        
        if (error.name === 'NotAllowedError' || error.message === 'Camera permission denied') {
          errorMessage = 'Camera permission denied. Please allow camera access and refresh.';
        } else if (error.name === 'NotFoundError') {
          errorMessage = 'No camera found. Please connect a camera and refresh.';
        } else if (error.name === 'NotReadableError') {
          errorMessage = 'Camera is in use by another application. Please close other camera apps and refresh.';
        }
        
        showError(errorMessage);
      }
    }

    // Create video element for AR display
    function createARVideo() {
      // Remove existing video if any
      const existingVideo = document.querySelector('#ar-video');
      if (existingVideo) {
        existingVideo.remove();
      }
      
      // Create new video element
      videoElement = document.createElement('video');
      videoElement.id = 'ar-video';
      videoElement.autoplay = true;
      videoElement.muted = true;
      videoElement.playsInline = true;
      videoElement.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: 1;
      `;
      
      // Set video source
      videoElement.srcObject = cameraStream;
      
      // Add to AR container
      const arContainer = document.getElementById('ar-container');
      arContainer.appendChild(videoElement);
      
      // Wait for video to load
      videoElement.addEventListener('loadedmetadata', () => {
        console.log('üìπ AR Video ready:', videoElement.videoWidth, 'x', videoElement.videoHeight);
        updateLoadingMessage('Interactive AR Video Ready!');
      });
      
      // Handle video errors
      videoElement.addEventListener('error', (e) => {
        console.error('‚ùå Video error:', e);
        showError('Video playback error. Please refresh the page.');
      });
    }

    // Update loading message
    function updateLoadingMessage(mainText) {
      const mainTextEl = document.getElementById('loading-main-text');
      if (mainTextEl) mainTextEl.textContent = mainText;
    }

    // Initialize AR Scene - enhanced with interactive features
    function initializeAR() {
      updateLoadingMessage('Starting Interactive AR overlay...');
      console.log('üéØ Starting enhanced interactive AR overlay');
      
      // Create interactive AR objects
      createInteractiveObjects();
      
      // Setup touch and gesture controls
      setupTouchControls();
      
      // Setup camera movement detection
      setupCameraTracking();
      
      // Hide loading screen
      setTimeout(() => {
        hideLoadingScreen();
        setupAREventListeners();
        updateStatus('Interactive AR Ready - Touch and move objects!', 'ar');
        
        // Start physics simulation
        startPhysicsSimulation();
      }, 1000);
    }

    // Create interactive AR objects with physics properties
    function createInteractiveObjects() {
      const objectsContainer = document.getElementById('ar-objects');
      
      // Clear existing objects
      objectsContainer.innerHTML = '';
      
      // Create interactive box
      const box = createARObject('box', {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
        width: 100,
        height: 100,
        type: 'box',
        color: '#4CC3D9',
        velocity: { x: 0, y: 0 },
        rotation: 0,
        rotationSpeed: 2
      });
      
      // Create interactive sphere
      const sphere = createARObject('sphere', {
        x: window.innerWidth * 0.3,
        y: window.innerHeight * 0.4,
        width: 80,
        height: 80,
        type: 'sphere',
        color: '#EF2D5E',
        velocity: { x: 1, y: 1 },
        bounce: 0.8
      });
      
      // Create interactive text
      const text = createARObject('text', {
        x: window.innerWidth * 0.7,
        y: window.innerHeight * 0.6,
        width: 120,
        height: 40,
        type: 'text',
        color: '#FFC65D',
        text: 'Touch Me!',
        velocity: { x: 0, y: 0 }
      });
      
      arObjects = [box, sphere, text];
    }

    // Create a single interactive AR object
    function createARObject(id, properties) {
      const obj = document.createElement('div');
      obj.id = `ar-${id}`;
      obj.className = 'ar-object interactive';
      
      // Set object properties
      Object.assign(obj, properties);
      
      // Apply styles based on type
      if (properties.type === 'box') {
        obj.style.cssText = `
          position: absolute;
          left: ${properties.x}px;
          top: ${properties.y}px;
          width: ${properties.width}px;
          height: ${properties.height}px;
          background: linear-gradient(45deg, ${properties.color}, #2196F3);
          border-radius: 10px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
          cursor: grab;
          user-select: none;
          transition: transform 0.1s ease;
          z-index: 10;
        `;
      } else if (properties.type === 'sphere') {
        obj.style.cssText = `
          position: absolute;
          left: ${properties.x}px;
          top: ${properties.y}px;
          width: ${properties.width}px;
          height: ${properties.height}px;
          background: radial-gradient(circle, ${properties.color}, #C2185B);
          border-radius: 50%;
          box-shadow: 0 6px 24px rgba(0,0,0,0.3);
          cursor: grab;
          user-select: none;
          transition: transform 0.1s ease;
          z-index: 10;
        `;
      } else if (properties.type === 'text') {
        obj.style.cssText = `
          position: absolute;
          left: ${properties.x}px;
          top: ${properties.y}px;
          width: ${properties.width}px;
          height: ${properties.height}px;
          color: ${properties.color};
          font-size: 18px;
          font-weight: bold;
          text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
          cursor: grab;
          user-select: none;
          text-align: center;
          line-height: ${properties.height}px;
          transition: transform 0.1s ease;
          z-index: 10;
        `;
        obj.textContent = properties.text;
      }
      
      // Add to container
      document.getElementById('ar-objects').appendChild(obj);
      
      return obj;
    }

    // Setup touch controls for interactive objects
    function setupTouchControls() {
      const objectsContainer = document.getElementById('ar-objects');
      
      // Touch events for mobile
      objectsContainer.addEventListener('touchstart', handleTouchStart);
      objectsContainer.addEventListener('touchmove', handleTouchMove);
      objectsContainer.addEventListener('touchend', handleTouchEnd);
      
      // Mouse events for desktop
      objectsContainer.addEventListener('mousedown', handleMouseDown);
      objectsContainer.addEventListener('mousemove', handleMouseMove);
      objectsContainer.addEventListener('mouseup', handleMouseUp);
      
      // Prevent default touch behaviors
      objectsContainer.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
      objectsContainer.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
    }

    // Handle touch start
    function handleTouchStart(e) {
      const touch = e.touches[0];
      const element = document.elementFromPoint(touch.clientX, touch.clientY);
      
      if (element && element.classList.contains('ar-object')) {
        selectedObject = element;
        isDragging = true;
        dragStartPos = { x: touch.clientX, y: touch.clientY };
        
        // Add dragging visual feedback
        element.style.transform = 'scale(1.1)';
        element.style.cursor = 'grabbing';
        
        // Store initial position
        element.initialX = parseInt(element.style.left);
        element.initialY = parseInt(element.style.top);
        
        e.preventDefault();
      }
      
      // Handle pinch gestures for scaling
      if (e.touches.length === 2) {
        touchStartDistance = getDistance(e.touches[0], e.touches[1]);
        if (selectedObject) {
          selectedObject.initialScale = selectedObject.scale || 1;
        }
      }
    }

    // Handle touch move
    function handleTouchMove(e) {
      if (isDragging && selectedObject) {
        const touch = e.touches[0];
        const deltaX = touch.clientX - dragStartPos.x;
        const deltaY = touch.clientY - dragStartPos.y;
        
        // Update object position
        const newX = selectedObject.initialX + deltaX;
        const newY = selectedObject.initialY + deltaY;
        
        // Keep object within screen bounds
        const maxX = window.innerWidth - selectedObject.offsetWidth;
        const maxY = window.innerHeight - selectedObject.offsetHeight;
        
        selectedObject.style.left = Math.max(0, Math.min(maxX, newX)) + 'px';
        selectedObject.style.top = Math.max(0, Math.min(maxY, newY)) + 'px';
        
        // Update physics properties
        selectedObject.x = parseInt(selectedObject.style.left);
        selectedObject.y = parseInt(selectedObject.style.top);
        
        e.preventDefault();
      }
      
      // Handle pinch scaling
      if (e.touches.length === 2 && selectedObject) {
        const currentDistance = getDistance(e.touches[0], e.touches[1]);
        const scale = (currentDistance / touchStartDistance) * selectedObject.initialScale;
        
        // Limit scale range
        const clampedScale = Math.max(0.5, Math.min(2.0, scale));
        selectedObject.style.transform = `scale(${clampedScale})`;
        selectedObject.scale = clampedScale;
        
        e.preventDefault();
      }
    }

    // Handle touch end
    function handleTouchEnd(e) {
      if (isDragging && selectedObject) {
        // Remove dragging visual feedback
        selectedObject.style.transform = selectedObject.scale ? `scale(${selectedObject.scale})` : '';
        selectedObject.style.cursor = 'grab';
        
        // Add some velocity based on drag speed
        const touch = e.changedTouches[0];
        const deltaX = touch.clientX - dragStartPos.x;
        const deltaY = touch.clientY - dragStartPos.y;
        
        selectedObject.velocity.x = deltaX * 0.1;
        selectedObject.velocity.y = deltaY * 0.1;
        
        isDragging = false;
        selectedObject = null;
      }
    }

    // Handle mouse down
    function handleMouseDown(e) {
      if (e.target.classList.contains('ar-object')) {
        selectedObject = e.target;
        isDragging = true;
        dragStartPos = { x: e.clientX, y: e.clientY };
        
        selectedObject.style.transform = 'scale(1.1)';
        selectedObject.style.cursor = 'grabbing';
        
        selectedObject.initialX = parseInt(selectedObject.style.left);
        selectedObject.initialY = parseInt(selectedObject.style.top);
        
        e.preventDefault();
      }
    }

    // Handle mouse move
    function handleMouseMove(e) {
      if (isDragging && selectedObject) {
        const deltaX = e.clientX - dragStartPos.x;
        const deltaY = e.clientY - dragStartPos.y;
        
        const newX = selectedObject.initialX + deltaX;
        const newY = selectedObject.initialY + deltaY;
        
        const maxX = window.innerWidth - selectedObject.offsetWidth;
        const maxY = window.innerHeight - selectedObject.offsetHeight;
        
        selectedObject.style.left = Math.max(0, Math.min(maxX, newX)) + 'px';
        selectedObject.style.top = Math.max(0, Math.min(maxY, newY)) + 'px';
        
        selectedObject.x = parseInt(selectedObject.style.left);
        selectedObject.y = parseInt(selectedObject.style.top);
        
        e.preventDefault();
      }
    }

    // Handle mouse up
    function handleMouseUp(e) {
      if (isDragging && selectedObject) {
        selectedObject.style.transform = selectedObject.scale ? `scale(${selectedObject.scale})` : '';
        selectedObject.style.cursor = 'grab';
        
        const deltaX = e.clientX - dragStartPos.x;
        const deltaY = e.clientY - dragStartPos.y;
        
        selectedObject.velocity.x = deltaX * 0.1;
        selectedObject.velocity.y = deltaY * 0.1;
        
        isDragging = false;
        selectedObject = null;
      }
    }

    // Calculate distance between two touch points
    function getDistance(touch1, touch2) {
      const dx = touch1.clientX - touch2.clientX;
      const dy = touch1.clientY - touch2.clientY;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Setup camera movement tracking
    function setupCameraTracking() {
      if (videoElement) {
        // Track camera movement for object interaction
        let lastFrame = null;
        
        function trackCameraMovement() {
          if (videoElement.videoWidth > 0) {
            // Simple motion detection based on video changes
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 48;
            
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            if (lastFrame) {
              let motion = 0;
              for (let i = 0; i < imageData.data.length; i += 4) {
                const diff = Math.abs(imageData.data[i] - lastFrame[i]);
                motion += diff;
              }
              
              const motionThreshold = 1000;
              if (motion > motionThreshold) {
                // Camera is moving - add some randomness to object movement
                arObjects.forEach(obj => {
                  if (obj.velocity && !isDragging) {
                    obj.velocity.x += (Math.random() - 0.5) * 0.5;
                    obj.velocity.y += (Math.random() - 0.5) * 0.5;
                  }
                });
              }
            }
            
            lastFrame = new Uint8ClampedArray(imageData.data);
          }
          
          requestAnimationFrame(trackCameraMovement);
        }
        
        trackCameraMovement();
      }
    }

    // Start physics simulation for objects
    function startPhysicsSimulation() {
      function updatePhysics() {
        arObjects.forEach(obj => {
          if (obj.velocity && !isDragging) {
            // Update position based on velocity
            obj.x += obj.velocity.x;
            obj.y += obj.velocity.y;
            
            // Apply friction
            obj.velocity.x *= 0.98;
            obj.velocity.y *= 0.98;
            
            // Bounce off screen edges
            const maxX = window.innerWidth - obj.offsetWidth;
            const maxY = window.innerHeight - obj.offsetHeight;
            
            if (obj.x <= 0 || obj.x >= maxX) {
              obj.velocity.x *= -0.8;
              obj.x = Math.max(0, Math.min(maxX, obj.x));
            }
            
            if (obj.y <= 0 || obj.y >= maxY) {
              obj.velocity.y *= -0.8;
              obj.y = Math.max(0, Math.min(maxY, obj.y));
            }
            
            // Update visual position
            obj.style.left = obj.x + 'px';
            obj.style.top = obj.y + 'px';
            
            // Apply rotation for box
            if (obj.type === 'box') {
              obj.rotation += obj.rotationSpeed || 0;
              obj.style.transform = `rotate(${obj.rotation}deg)`;
            }
          }
        });
        
        requestAnimationFrame(updatePhysics);
      }
      
      updatePhysics();
    }

    // Setup marker detection events - enhanced for interactive AR
    function setupMarkerDetection() {
      console.log('üéØ Interactive AR mode - objects respond to touch and camera movement');
    }

    // Animate objects when marker is found - updated for interactive AR
    function animateObjectsIn() {
      arObjects.forEach((obj, index) => {
        if (obj && objectStates[obj.id]) {
          // Fade in with staggered timing
          obj.style.opacity = '0';
          obj.style.transform = 'scale(0)';
          
          setTimeout(() => {
            obj.style.transition = 'all 0.5s ease';
            obj.style.opacity = '1';
            obj.style.transform = obj.scale ? `scale(${obj.scale})` : 'scale(1)';
          }, index * 200);
        }
      });
    }

    // Add CSS animations for AR objects
    function addCSSAnimations() {
      if (!document.getElementById('ar-animations')) {
        const style = document.createElement('style');
        style.id = 'ar-animations';
        style.textContent = `
          .ar-object {
            transition: all 0.3s ease;
          }
          
          .ar-object:hover {
            filter: brightness(1.2);
          }
          
          .ar-object.interactive {
            cursor: grab;
          }
          
          .ar-object.interactive:active {
            cursor: grabbing;
          }
          
          @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
          }
          
          .ar-object.pulse {
            animation: pulse 2s ease-in-out infinite;
          }
        `;
        document.head.appendChild(style);
      }
    }

    // Hide loading screen
    function hideLoadingScreen() {
      const loadingScreen = document.getElementById('loading-screen');
      loadingScreen.style.opacity = '0';
      setTimeout(() => {
        loadingScreen.style.display = 'none';
      }, 500);
    }

    // Show error message
    function showError(message) {
      console.error('‚ùå AR Error:', message);
      const errorDiv = document.getElementById('error-message');
      const errorText = document.getElementById('error-text');
      errorText.textContent = message;
      errorDiv.style.display = 'block';
      hideLoadingScreen();
      updateStatus('Error: ' + message, 'error');
    }

    // Update status indicator
    function updateStatus(text, type) {
      const statusText = document.getElementById('status-text');
      const statusDot = document.getElementById('status-indicator');
      
      if (statusText) statusText.textContent = text;
      if (statusDot) statusDot.className = `status-dot ${type}`;
    }

    // Toggle AR object visibility - enhanced for interactive AR
    function toggleObject(objectId) {
      const object = document.querySelector(`#${objectId}`);
      const option = document.querySelector(`[onclick="toggleObject('${objectId}')"]`);
      
      if (object && option) {
        objectStates[objectId] = !objectStates[objectId];
        
        if (objectStates[objectId]) {
          // Show object with animation
          object.style.transition = 'all 0.5s ease';
          object.style.opacity = '1';
          object.style.transform = object.scale ? `scale(${object.scale})` : 'scale(1)';
        } else {
          // Hide object with animation
          object.style.transition = 'all 0.3s ease';
          object.style.opacity = '0';
          object.style.transform = 'scale(0)';
        }
        
        option.classList.toggle('active', objectStates[objectId]);
        
        console.log(`üé≤ ${objectId} ${objectStates[objectId] ? 'shown' : 'hidden'}`);
      }
    }

    // Spawn new AR object
    function spawnObject(type = 'random') {
      const types = ['box', 'sphere', 'text', 'triangle', 'star'];
      const colors = ['#4CC3D9', '#EF2D5E', '#FFC65D', '#7BC8A4', '#FF6B6B', '#9C27B0'];
      
      if (type === 'random') {
        type = types[Math.floor(Math.random() * types.length)];
      }
      
      const color = colors[Math.floor(Math.random() * colors.length)];
      const x = Math.random() * (window.innerWidth - 100);
      const y = Math.random() * (window.innerHeight - 100);
      
      let properties = {
        x: x,
        y: y,
        width: 60 + Math.random() * 40,
        height: 60 + Math.random() * 40,
        type: type,
        color: color,
        velocity: { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 }
      };
      
      if (type === 'box') {
        properties.rotation = Math.random() * 360;
        properties.rotationSpeed = 1 + Math.random() * 3;
      } else if (type === 'text') {
        properties.text = 'New!';
        properties.width = 80;
        properties.height = 30;
      }
      
      const newObj = createARObject(`obj-${Date.now()}`, properties);
      arObjects.push(newObj);
      
      // Animate in
      newObj.style.opacity = '0';
      newObj.style.transform = 'scale(0)';
      setTimeout(() => {
        newObj.style.transition = 'all 0.5s ease';
        newObj.style.opacity = '1';
        newObj.style.transform = 'scale(1)';
      }, 100);
      
      console.log(`üéØ Spawned new ${type} object`);
      updateStatus(`Spawned ${type}`, 'ar');
    }

    // Change object colors randomly
    function changeColors() {
      const colors = ['#4CC3D9', '#EF2D5E', '#FFC65D', '#7BC8A4', '#FF6B6B', '#9C27B0', '#00BCD4', '#E91E63'];
      
      arObjects.forEach(obj => {
        if (obj.type === 'box') {
          const newColor = colors[Math.floor(Math.random() * colors.length)];
          obj.style.background = `linear-gradient(45deg, ${newColor}, #2196F3)`;
        } else if (obj.type === 'sphere') {
          const newColor = colors[Math.floor(Math.random() * colors.length)];
          obj.style.background = `radial-gradient(circle, ${newColor}, #C2185B)`;
        } else if (obj.type === 'text') {
          const newColor = colors[Math.floor(Math.random() * colors.length)];
          obj.style.color = newColor;
        }
      });
      
      console.log('üé® Changed all object colors');
      updateStatus('Colors Changed', 'ar');
    }

    // Toggle physics simulation
    function togglePhysics() {
      const physicsEnabled = !window.physicsEnabled;
      window.physicsEnabled = physicsEnabled;
      
      // Update UI text
      const physicsToggle = document.getElementById('physics-toggle');
      if (physicsToggle) {
        physicsToggle.textContent = physicsEnabled ? 'Physics On' : 'Physics Off';
      }
      
      arObjects.forEach(obj => {
        if (obj.velocity) {
          if (physicsEnabled) {
            obj.velocity.x = (Math.random() - 0.5) * 2;
            obj.velocity.y = (Math.random() - 0.5) * 2;
          } else {
            obj.velocity.x = 0;
            obj.velocity.y = 0;
          }
        }
      });
      
      console.log(`‚ö° Physics ${physicsEnabled ? 'enabled' : 'disabled'}`);
      updateStatus(`Physics ${physicsEnabled ? 'On' : 'Off'}`, physicsEnabled ? 'ar' : 'camera');
    }

    // Change marker type - enhanced for interactive AR
    function changeMarkerType() {
      const markerTypeSpan = document.getElementById('marker-type');
      
      if (currentMarker === 'hiro') {
        currentMarker = 'interactive';
        markerTypeSpan.textContent = 'Interactive AR';
      } else {
        currentMarker = 'hiro';
        markerTypeSpan.textContent = 'Hiro Marker';
      }
      
      console.log(`üéØ Switched to ${currentMarker} mode`);
    }

    // Reset AR scene - enhanced for interactive AR
    function resetScene() {
      console.log('üîÑ Resetting interactive AR scene...');
      
      // Remove all objects
      arObjects.forEach(obj => obj.remove());
      arObjects = [];
      
      // Reset object states
      Object.keys(objectStates).forEach(id => {
        objectStates[id] = true;
        const option = document.querySelector(`[onclick="toggleObject('${id}')"]`);
        if (option) option.classList.add('active');
      });
      
      // Reset marker type
      currentMarker = 'hiro';
      const markerTypeSpan = document.getElementById('marker-type');
      if (markerTypeSpan) markerTypeSpan.textContent = 'Interactive AR';
      
      // Recreate objects
      createInteractiveObjects();
      
      updateStatus('Scene Reset', 'ar');
    }

    // Toggle camera - enhanced for interactive AR
    function toggleCamera() {
      cameraActive = !cameraActive;
      
      if (cameraActive && videoElement) {
        videoElement.style.display = 'block';
        updateStatus('Camera Active', 'camera');
      } else if (videoElement) {
        videoElement.style.display = 'none';
        updateStatus('Camera Paused', 'error');
      }
      
      console.log(`üìπ Camera ${cameraActive ? 'enabled' : 'disabled'}`);
    }

    // Retry camera access - enhanced for interactive AR
    function retryCamera() {
      console.log('üîÑ Retrying Interactive AR...');
      const errorDiv = document.getElementById('error-message');
      errorDiv.style.display = 'none';
      
      const loadingScreen = document.getElementById('loading-screen');
      loadingScreen.style.display = 'flex';
      updateLoadingMessage('Retrying Interactive AR...');
      
      setTimeout(() => {
        initializeCamera();
      }, 1000);
    }

    // Toggle fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().then(() => {
          console.log('‚õ∂ Entered fullscreen mode');
        }).catch(err => {
          console.log('‚ùå Failed to enter fullscreen:', err);
        });
      } else {
        document.exitFullscreen().then(() => {
          console.log('‚õ∂ Exited fullscreen mode');
        });
      }
    }

    // Capture screenshot - enhanced for interactive AR
    function captureScreenshot() {
      try {
        // Create a canvas to capture the AR scene
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to match video
        if (videoElement) {
          canvas.width = videoElement.videoWidth || 640;
          canvas.height = videoElement.videoHeight || 480;
        } else {
          canvas.width = 640;
          canvas.height = 480;
        }
        
        // Draw video frame
        if (videoElement && videoElement.videoWidth > 0) {
          ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        }
        
        // Draw AR objects on top
        arObjects.forEach(obj => {
          if (obj.style.opacity !== '0') {
            // Convert screen position to canvas position
            const rect = obj.getBoundingClientRect();
            const scaleX = canvas.width / window.innerWidth;
            const scaleY = canvas.height / window.innerHeight;
            
            // Draw a representation of the AR object
            if (obj.type === 'box') {
              ctx.fillStyle = obj.style.background || '#4CC3D9';
              ctx.fillRect(
                rect.left * scaleX, 
                rect.top * scaleY, 
                rect.width * scaleX, 
                rect.height * scaleY
              );
            } else if (obj.type === 'sphere') {
              ctx.fillStyle = obj.style.background || '#EF2D5E';
              ctx.beginPath();
              ctx.arc(
                (rect.left + rect.width/2) * scaleX,
                (rect.top + rect.height/2) * scaleY,
                Math.min(rect.width, rect.height) * scaleX / 2,
                0, 2 * Math.PI
              );
              ctx.fill();
            }
          }
        });
        
        // Create download link
        const link = document.createElement('a');
        link.download = `interactive-ar-${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();
        
        console.log('üì∏ Interactive AR screenshot captured');
        updateStatus('Screenshot Saved', 'ar');
        
        setTimeout(() => {
          updateStatus('Interactive AR Ready - Touch and move objects!', 'ar');
        }, 2000);
        
      } catch (error) {
        console.error('üì∏ Screenshot failed:', error);
        updateStatus('Screenshot Failed', 'error');
      }
    }

    // Setup AR event listeners - updated for HTML AR
    function setupAREventListeners() {
      // Handle device orientation for mobile
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', function(event) {
          // Optionally handle device orientation for better AR tracking
        });
      }

      // Handle touch events for interaction
      document.addEventListener('touchstart', function(e) {
        // Add touch-based interactions if needed
      });

      // Handle click events for AR object interaction
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('ar-object')) {
          // AR object clicked - could add more interaction here
          console.log('üéØ AR object clicked:', e.target.id);
        }
      });
    }

    // Navigation
    function goHome() {
      if (window.showcaseFramework && window.showcaseFramework.goHome) {
        window.showcaseFramework.goHome();
      } else {
        window.location.href = '../index.html';
      }
    }

    // Quality mode detection and optimization - simplified for HTML AR
    function getQualityMode() {
      const cores = navigator.hardwareConcurrency || 1;
      const memory = navigator.deviceMemory || 1;

      // Pi detection logic
      if (cores <= 4 && memory <= 1) return 'low';
      if (cores <= 4 && memory <= 2) return 'medium';
      return 'high';
    }

    // Apply quality optimizations - simplified for HTML AR
    function applyQualityOptimizations() {
      const quality = getQualityMode();
      console.log(`üéÆ AR Quality Mode: ${quality}`);

      // Adjust animation complexity based on quality
      const arObjects = document.querySelectorAll('.ar-object');
      
      switch (quality) {
        case 'low':
          // Low quality optimizations for Pi 3B+
          arObjects.forEach(obj => {
            obj.style.transition = 'all 0.3s ease';
          });
          break;
          
        case 'medium':
          // Medium quality for Pi 4
          arObjects.forEach(obj => {
            obj.style.transition = 'all 0.5s ease';
          });
          break;
          
        case 'high':
          // High quality for Pi 5 and desktop
          arObjects.forEach(obj => {
            obj.style.transition = 'all 0.8s ease';
          });
          break;
      }
    }

    // Apply optimizations when page loads
    document.addEventListener('DOMContentLoaded', applyQualityOptimizations);

    // Console commands for debugging - Enhanced for Interactive AR
    window.arDebug = {
      getMarkerState: () => isMarkerVisible,
      getObjectStates: () => objectStates,
      getCurrentMarker: () => currentMarker,
      forceMarkerFound: () => {
        isMarkerVisible = true;
        animateObjectsIn();
        updateStatus('Marker Detected (Forced)', 'ar');
      },
      resetAll: resetScene,
      checkCameraStatus: () => {
        if (videoElement) {
          console.log('üìπ AR Video element found:', videoElement);
          console.log('üìä Video stats:', {
            videoWidth: videoElement.videoWidth,
            videoHeight: videoElement.videoHeight,
            readyState: videoElement.readyState,
            paused: videoElement.paused,
            srcObject: !!videoElement.srcObject,
            display: videoElement.style.display
          });
        } else {
          console.log('‚ùå No AR video element found');
        }
        
        // Check for camera stream
        if (cameraStream) {
          console.log('üìπ Camera stream active:', cameraStream);
          const tracks = cameraStream.getTracks();
          tracks.forEach(track => {
            console.log('üìπ Track:', track.kind, track.enabled, track.readyState);
          });
        } else {
          console.log('‚ùå No camera stream found');
        }
        
        return { videoElement, cameraStream };
      },
      forceHideLoading: () => {
        const loadingScreen = document.getElementById('loading-screen');
        if (loadingScreen) {
          loadingScreen.style.display = 'none';
        }
      },
      testBasicCamera: async () => {
        try {
          console.log('üß™ Testing basic camera access...');
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 320, height: 240 }
          });
          console.log('‚úÖ Basic camera access works!');
          stream.getTracks().forEach(track => track.stop());
          return true;
        } catch (error) {
          console.error('‚ùå Basic camera test failed:', error);
          return false;
        }
      },
      showAllObjects: () => {
        arObjects.forEach(obj => {
          obj.style.opacity = '1';
          obj.style.transform = obj.scale ? `scale(${obj.scale})` : 'scale(1)';
        });
        console.log('üéØ All AR objects shown');
      },
      hideAllObjects: () => {
        arObjects.forEach(obj => {
          obj.style.opacity = '0';
          obj.style.transform = 'scale(0)';
        });
        console.log('üéØ All AR objects hidden');
      },
      spawnRandomObject: () => spawnObject('random'),
      changeAllColors: () => changeColors(),
      togglePhysicsSim: () => togglePhysics(),
      getObjectCount: () => arObjects.length,
      getObjectPositions: () => {
        return arObjects.map(obj => ({
          id: obj.id,
          type: obj.type,
          x: obj.x,
          y: obj.y,
          velocity: obj.velocity
        }));
      },
      setObjectVelocity: (objectId, vx, vy) => {
        const obj = arObjects.find(o => o.id === objectId);
        if (obj && obj.velocity) {
          obj.velocity.x = vx;
          obj.velocity.y = vy;
          console.log(`üéØ Set velocity for ${objectId}:`, { x: vx, y: vy });
        }
      },
      addPulseEffect: () => {
        arObjects.forEach(obj => {
          obj.classList.add('pulse');
        });
        console.log('üéØ Added pulse effect to all objects');
      },
      removePulseEffect: () => {
        arObjects.forEach(obj => {
          obj.classList.remove('pulse');
        });
        console.log('üéØ Removed pulse effect from all objects');
      }
    };

    console.log('üéØ Interactive AR Debug commands available:');
    console.log('  arDebug.checkCameraStatus() - Check camera/video status');
    console.log('  arDebug.testBasicCamera() - Test basic camera access');
    console.log('  arDebug.forceHideLoading() - Force hide loading screen');
    console.log('  arDebug.getMarkerState() - Check if marker is visible');
    console.log('  arDebug.resetAll() - Reset entire scene');
    console.log('  arDebug.showAllObjects() - Show all AR objects');
    console.log('  arDebug.hideAllObjects() - Hide all AR objects');
    console.log('  arDebug.forceMarkerFound() - Force marker detection');
    console.log('  arDebug.spawnRandomObject() - Spawn a new random object');
    console.log('  arDebug.changeAllColors() - Change colors of all objects');
    console.log('  arDebug.togglePhysicsSim() - Toggle physics simulation');
    console.log('  arDebug.getObjectCount() - Get total number of objects');
    console.log('  arDebug.getObjectPositions() - Get positions of all objects');
    console.log('  arDebug.setObjectVelocity(id, vx, vy) - Set object velocity');
    console.log('  arDebug.addPulseEffect() - Add pulse animation to objects');
    console.log('  arDebug.removePulseEffect() - Remove pulse animation');
    console.log('');
    console.log('üéÆ Interactive Features:');
    console.log('  ‚Ä¢ Touch/drag objects to move them around');
    console.log('  ‚Ä¢ Pinch to resize objects');
    console.log('  ‚Ä¢ Objects bounce off screen edges');
    console.log('  ‚Ä¢ Camera movement affects object behavior');
    console.log('  ‚Ä¢ Spawn new objects with ‚ú® button');
    console.log('  ‚Ä¢ Change colors with üé® button');
    console.log('  ‚Ä¢ Toggle physics with ‚ö° button');
  </script>
</body>
</html>
