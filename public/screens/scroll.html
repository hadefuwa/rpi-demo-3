<section id="screen-scroll" class="screen">
  <!-- Header with logo and navigation -->
  <header class="header">
    <img src="../assets/Matrix.png" alt="Matrix TSL" class="logo matrix-logo" />
    <button id="btnHome" class="home-button" aria-label="Home">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
        <polyline points="9 22 9 12 15 12 15 22"></polyline>
      </svg>
    </button>
  </header>
  
  <!-- Main content -->
  <div class="panel">
    <h2>🎢 Scroll Animation Test</h2>
    
    <div class="content">
      <div id="scrollbox" class="scrollbox">
        <!-- Items will be generated dynamically -->
      </div>
    </div>
  </div>
</section>

<style>
  /* Page Specific Styles - All scoped to #screen-scroll */
  #screen-scroll {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    max-height: 100vh;
    max-width: 100vw;
    overflow: hidden;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: #e4e6f1;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    padding: 0;
    position: relative;
    box-sizing: border-box;
    cursor: none !important; /* Force hide cursor */
    -webkit-touch-callout: none !important; /* Disable iOS callout */
    -webkit-user-select: none !important; /* Disable text selection */
    -khtml-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
  }
  
  /* Force hide cursor and disable selection on ALL child elements */
  #screen-scroll *,
  #screen-scroll *:before,
  #screen-scroll *:after {
    cursor: none !important;
    -webkit-user-select: none !important;
    -khtml-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
    -webkit-touch-callout: none !important;
  }
  
  /* Animated background particles */
  #screen-scroll::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: 
      radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
      radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
    animation: backgroundShift 15s ease-in-out infinite;
    z-index: 1;
  }
  
  @keyframes backgroundShift {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.1); }
  }
  
  /* Header styles */
  #screen-scroll .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    width: 100%;
    box-sizing: border-box;
    z-index: 100;
    position: relative;
  }
  
  /* Home button styles */
  #screen-scroll .home-button {
    width: 40px;
    height: 40px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #ffffff;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
  }
  
  #screen-scroll .home-button:hover {
    background: rgba(255, 255, 255, 0.25);
    transform: translateY(-2px) scale(1.05);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
  }
  
  #screen-scroll .home-button:active {
    transform: translateY(0) scale(0.98);
  }
  
  /* Matrix logo styles */
  #screen-scroll .matrix-logo {
    height: 36px;
    width: auto;
    opacity: 0.95;
    transition: all 0.3s ease;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
  }
  
  #screen-scroll .matrix-logo:hover {
    opacity: 1;
    transform: scale(1.05);
  }
  
  /* Panel styles */
  #screen-scroll .panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 20px;
    gap: 24px;
    width: 100%;
    max-height: calc(100vh - 64px);
    overflow: hidden;
    box-sizing: border-box;
    position: relative;
    z-index: 2;
  }
  
  #screen-scroll h2 {
    font-size: 32px;
    font-weight: 700;
    margin: 0;
    color: #ffffff;
    text-align: center;
    letter-spacing: -0.5px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    animation: titlePulse 3s ease-in-out infinite;
  }
  
  @keyframes titlePulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
  }
  
  #screen-scroll .content {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    padding: 24px;
    border-radius: 20px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    width: 100%;
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    box-shadow: 0 8px 40px rgba(0, 0, 0, 0.1);
    display: flex;
    flex-direction: column;
    gap: 20px;
    flex: 1;
  /* Fill available space within panel; no explicit max-height to maximize scroll area */
  }
  
  
  /* Scrollbox styles */
  #screen-scroll .scrollbox {
    flex: 1;
    min-height: 200px;
    overflow-y: auto;
    overflow-x: hidden;
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 16px;
    padding: 16px;
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    position: relative;
    cursor: none !important; /* Force hide cursor */
    touch-action: auto;
    overscroll-behavior: contain;
    /* Prevent text selection during scrolling */
    -webkit-user-select: none !important;
    -khtml-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
    -webkit-touch-callout: none !important;
  }
  
  /* Custom scrollbar */
  #screen-scroll .scrollbox::-webkit-scrollbar {
    width: 8px;
  }
  
  #screen-scroll .scrollbox::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
  }
  
  #screen-scroll .scrollbox::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
    transition: background 0.3s ease;
  }
  
  #screen-scroll .scrollbox::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }
  
  /* Scroll items */
  #screen-scroll .scroll-item {
    padding: 16px;
    margin: 12px 0;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    cursor: none !important; /* Force hide cursor */
    position: relative;
    overflow: hidden;
    transform: translateY(20px);
    opacity: 0;
    animation: slideInUp 0.6s ease-out forwards;
    touch-action: manipulation;
    -webkit-touch-callout: none !important;
    /* Prevent text selection on items */
    -webkit-user-select: none !important;
    -khtml-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
  }
  
  #screen-scroll .scroll-item:nth-child(even) {
    animation-delay: 0.1s;
  }
  
  #screen-scroll .scroll-item:nth-child(3n) {
    animation-delay: 0.2s;
  }
  
  @keyframes slideInUp {
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
  
  /* Hover effects removed for list items */
  
  /* Touch-specific active state (replaces hover on touch devices) */
  #screen-scroll .scroll-item:active,
  #screen-scroll .scroll-item.touch-active {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0.2) 100%);
    transform: scale(0.98);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    border-color: rgba(255, 255, 255, 0.5);
  }
  
  /* Remove shimmer overlay entirely */
  #screen-scroll .scroll-item::before { content: none; }
  
  #screen-scroll .item-number {
    font-weight: 700;
    color: #ffffff;
    font-size: 18px;
  }
  
  #screen-scroll .item-text {
    color: rgba(255, 255, 255, 0.9);
    margin-top: 4px;
    font-size: 14px;
  }
  
  /* Scroll controls */
  /* (Removed old .scroll-controls and button styles to maximize scroll area) */
  
  /* (Removed old empty state styles) */
  
  /* Responsive design - optimized for Raspberry Pi screens */
  @media (max-width: 800px) {
    #screen-scroll .header {
      padding: 10px 14px;
    }
    
    #screen-scroll .panel {
      padding: 16px;
      gap: 16px;
    }
    
    #screen-scroll h2 {
      font-size: 28px;
    }
    
    #screen-scroll .content {
      padding: 20px;
      border-radius: 16px;
  /* No explicit max-height; let flex layout size it */
    }
    
    #screen-scroll .scrollbox {
      min-height: 150px;
    }
    
    #screen-scroll .scroll-item {
      padding: 14px;
      margin: 10px 0;
    }
    
    #screen-scroll .btn,
    #screen-scroll .btn-secondary {
      padding: 10px 20px;
      font-size: 14px;
    }
  }
  
  /* Extra small screens - like Raspberry Pi 5" display */
  @media (max-width: 480px) {
    #screen-scroll .header {
      padding: 8px 12px;
    }
    
    #screen-scroll .home-button {
      width: 36px;
      height: 36px;
    }
    
    #screen-scroll .matrix-logo {
      height: 32px;
    }
    
    #screen-scroll .panel {
      padding: 12px;
      gap: 12px;
    }
    
    #screen-scroll h2 {
      font-size: 24px;
    }
    
    #screen-scroll .content {
      padding: 16px;
      border-radius: 14px;
  /* No explicit max-height; let flex layout size it */
    }
    
    #screen-scroll .scrollbox {
      min-height: 120px;
      padding: 12px;
    }
    
    #screen-scroll .scroll-item {
      padding: 12px;
      margin: 8px 0;
    }
    
    #screen-scroll .item-number {
      font-size: 16px;
    }
    
    #screen-scroll .item-text {
      font-size: 13px;
    }
  /* Removed button, controls, and note responsive overrides */
  }
  
  /* Touch-specific optimizations */
  @media (pointer: coarse) {
    #screen-scroll .scroll-item {
      min-height: 44px; /* Touch target size */
    }
    
    /* Force hide all cursors on touch devices */
    #screen-scroll *,
    #screen-scroll *:before,
    #screen-scroll *:after {
      cursor: none !important;
    }
    
    /* Improve touch scrolling performance */
    #screen-scroll .scrollbox {
      -webkit-overflow-scrolling: touch;
      scroll-snap-type: none; /* Disable snap scrolling for smooth experience */
    }
  }
  
  /* Force cursor hiding and text selection prevention for ALL devices */
  #screen-scroll,
  #screen-scroll *,
  #screen-scroll *:before,
  #screen-scroll *:after,
  #screen-scroll *:hover,
  #screen-scroll *:active,
  #screen-scroll *:focus {
    cursor: none !important;
    -webkit-user-select: none !important;
    -khtml-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    user-select: none !important;
    -webkit-touch-callout: none !important;
  }

  /* No hover visuals on any device */
  @media (hover: hover) {
    #screen-scroll .scroll-item:hover { transform: none !important; box-shadow: none !important; }
  }

  /* Ensure no hover transforms apply at all */
  #screen-scroll .scroll-item:hover { transform: none !important; box-shadow: none !important; }

  /* While dragging/swiping, disable hover/pointer effects so scrolling is never blocked */
  #screen-scroll.dragging .scroll-item:hover {
    transform: none !important;
    box-shadow: none !important;
    border-color: rgba(255, 255, 255, 0.2) !important;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%) !important;
  }
</style>

<script>
  (function() {
    'use strict';
    
  let itemCounter = 0;
  const scrollBox = document.querySelector('#scrollbox');
  const screenEl = document.querySelector('#screen-scroll');
  const DRAG_TOLERANCE = 8; // px movement to consider as dragging
    // Infinite loop state
    let baseSetCount = 0;       // number of items in one base set
    let loopStartTop = 0;       // scrollTop where the middle (second) set begins
    let loopEndTop = 0;         // scrollTop where the third set begins
    let loopSpan = 0;           // distance between start of second and third set
    let loopEnabled = false;    // whether infinite loop is active
    let isLoopAdjusting = false;// guard to avoid recursive scroll handling
    
    function initApp() {
      console.log('Scroll Test app initialized');
      setupEventListeners();
      generateInitialItems();
      preventTextSelection();
      hideCursor();
  setupHoverDetection();
    }
    
    function preventTextSelection() {
      // Prevent text selection globally within the screen
      const screen = document.querySelector('#screen-scroll');
      if (screen) {
        screen.addEventListener('selectstart', function(e) {
          e.preventDefault();
          return false;
        });
        
        screen.addEventListener('dragstart', function(e) {
          e.preventDefault();
          return false;
        });
        
        // Prevent context menu
        screen.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          return false;
        });
      }
    }
    
    function hideCursor() {
      // Force cursor to be hidden
      const style = document.createElement('style');
      style.textContent = `
        #screen-scroll, #screen-scroll * {
          cursor: none !important;
        }
      `;
      document.head.appendChild(style);
    }

    function setupHoverDetection() {
      // If we ever detect a real mouse move, allow hover visuals
      const screen = document.querySelector('#screen-scroll');
      function onMouseMove(e) {
        if (!screen) return;
        // Heuristic: if movementX/Y exists and is small, assume a mouse
        if (typeof e.mozInputSource !== 'undefined' && e.mozInputSource === 1) {
          screen.classList.add('enable-hover');
          return;
        }
        const isMouse = e.sourceCapabilities ? e.sourceCapabilities.firesTouchEvents === false : true;
        if (isMouse) screen.classList.add('enable-hover');
      }
      window.addEventListener('mousemove', onMouseMove, { passive: true });
    }

  // Drag detection + pointer drag-to-scroll fallback for environments where touch is exposed as mouse
  let isPointerDragging = false;
  let dragStartY = 0;
  let dragStartX = 0;
  let dragStartScrollTop = 0;
  let activePointerId = null;

    function shouldUsePointerDragFallback(e) {
      // Use fallback when pointerType is 'mouse' or unknown; ignore right/middle buttons
      if (!e) return false;
      const isPrimaryButton = e.buttons === undefined ? e.button === 0 : (e.buttons & 1) === 1;
      if (!isPrimaryButton) return false;
      // If it's touch, let the browser handle native scrolling
      if (e.pointerType && e.pointerType === 'touch') return false;
      return true; // mouse/pen/unknown
    }

    function handlePointerDown(e) {
      if (!scrollBox) return;
      activePointerId = e.pointerId;
      dragStartY = e.clientY;
      dragStartX = e.clientX;
      dragStartScrollTop = scrollBox.scrollTop;
  // Immediately mark dragging to suppress hover during swipe start
  if (screenEl) screenEl.classList.add('dragging');
      if (shouldUsePointerDragFallback(e)) {
        isPointerDragging = true;
        try { scrollBox.setPointerCapture && scrollBox.setPointerCapture(e.pointerId); } catch (_) {}
      }
      // Don't prevent default here; only in move when actively fallback-dragging
    }

    function handlePointerMove(e) {
      if (activePointerId === null || e.pointerId !== activePointerId) return;
      const deltaY = e.clientY - dragStartY;
      const deltaX = e.clientX - dragStartX;
      if (Math.abs(deltaX) > DRAG_TOLERANCE || Math.abs(deltaY) > DRAG_TOLERANCE) {
        // Toggle dragging class to suppress hover while swiping
        if (screenEl) screenEl.classList.add('dragging');
      }
      if (!scrollBox) return;
      if (isPointerDragging) {
        scrollBox.scrollTop = dragStartScrollTop - deltaY;
        e.preventDefault();
      }
    }

    function handlePointerUp(e) {
      if (e && activePointerId !== null && e.pointerId !== activePointerId) return;
      isPointerDragging = false;
      activePointerId = null;
      // Let inertia finish; then remove dragging flag
      if (screenEl) setTimeout(() => screenEl.classList.remove('dragging'), 120);
    }
    
    function setupEventListeners() {
      // Home button
      const homeButton = document.querySelector('#btnHome');
      if (homeButton) {
        homeButton.addEventListener('click', goHome);
      }
      
  // (Removed Add/Clear buttons and handlers)
      
      // Add scroll event listener for dynamic effects
      if (scrollBox) {
        scrollBox.addEventListener('scroll', handleScroll);
          // Keep loop boundaries accurate on viewport changes
          window.addEventListener('resize', () => {
            requestAnimationFrame(computeLoopMetrics);
          }, { passive: true });
        
  // Simple touch event listeners - let browser handle native scrolling
  scrollBox.addEventListener('touchstart', handleTouchStart, { passive: true });
  scrollBox.addEventListener('touchmove', handleTouchMoveDetect, { passive: true });
  scrollBox.addEventListener('touchend', handleTouchEnd, { passive: true });
        
        // Prevent context menu on long touch but allow scrolling
        scrollBox.addEventListener('contextmenu', function(e) {
          e.preventDefault();
        });

  // Pointer-based drag-to-scroll fallback (for Pi touch that appears as mouse) and drag detection
  scrollBox.addEventListener('pointerdown', handlePointerDown);
  scrollBox.addEventListener('pointermove', handlePointerMove, { capture: true });
  scrollBox.addEventListener('pointerup', handlePointerUp);
  scrollBox.addEventListener('pointercancel', handlePointerUp);
  scrollBox.addEventListener('pointerleave', handlePointerUp);
      }
    }
    
    function generateInitialItems() {
      const messages = [
        "🚀 Welcome to the scroll test!",
        "📱 Touch and drag to scroll",
        "🎨 Watch the smooth animations",
        "⚡ Optimized for Raspberry Pi",
        "🌈 Beautiful gradient backgrounds",
        "🔥 Smooth 60fps scrolling",
        "✨ Modern glassmorphism design",
        "🎯 Perfect touch targets",
        "📐 100% responsive layout",
        "🎪 Interactive hover effects"
      ];
      
      messages.forEach((message, index) => {
        createScrollItem(message, index);
      });
    }
    
    function createScrollItem(text, index = null) {
      if (!scrollBox) return;
      
      const itemNumber = index !== null ? index + 1 : ++itemCounter + 10;
      const item = document.createElement('div');
      item.className = 'scroll-item';
      item.innerHTML = `
        <div class="item-number">Item #${itemNumber}</div>
        <div class="item-text">${text}</div>
      `;
      
      // Long-press to select; swipes and quick taps do nothing.
      let lpTimer = null;
      let startX = 0, startY = 0;
      let moved = false;
      let selectedFired = false;
      let downPointerId = null;
      const LONG_PRESS_MS = 500;
      const MOVE_TOLERANCE = 12; // px

      function clearLongPress() {
        if (lpTimer) { clearTimeout(lpTimer); lpTimer = null; }
      }

      function fireSelected(targetEl) {
        selectedFired = true;
        targetEl.classList.add('touch-active');
        showToast(`Selected item #${itemNumber}!`);
        setTimeout(() => targetEl.classList.remove('touch-active'), 300);
      }

      function onItemPointerDown(e) {
        // record initial position and arm long-press
        downPointerId = e.pointerId;
        startX = e.clientX;
        startY = e.clientY;
        moved = false;
        selectedFired = false;
        // Don't preventDefault here to allow list drag scrolling
        clearLongPress();
        lpTimer = setTimeout(() => {
          if (!moved) fireSelected(item);
        }, LONG_PRESS_MS);
      }

      function onItemPointerMove(e) {
        if (downPointerId === null || e.pointerId !== downPointerId) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        if (Math.abs(dx) > MOVE_TOLERANCE || Math.abs(dy) > MOVE_TOLERANCE) {
          moved = true;
          clearLongPress();
        }
      }

      function onItemPointerUp(e) {
        if (downPointerId !== null && e.pointerId !== downPointerId) return;
        clearLongPress();
        downPointerId = null;
        // If long press already fired we consider it handled; otherwise do nothing
      }

      function onItemPointerCancel() {
        clearLongPress();
        downPointerId = null;
      }

      item.addEventListener('pointerdown', onItemPointerDown);
      item.addEventListener('pointermove', onItemPointerMove, { capture: false });
      item.addEventListener('pointerup', onItemPointerUp);
      item.addEventListener('pointercancel', onItemPointerCancel);
      item.addEventListener('pointerleave', onItemPointerCancel);
      
      scrollBox.appendChild(item);
      
      // Trigger reflow for animation
      requestAnimationFrame(() => {
        item.style.animationDelay = '0s';
      });
    }
    
  // (Removed addMoreItems and clearAllItems as no longer used)
    
    function handleScroll() {
      if (!scrollBox) return;
      
      const items = scrollBox.querySelectorAll('.scroll-item');
      const scrollBoxRect = scrollBox.getBoundingClientRect();
      
      items.forEach(item => {
        const itemRect = item.getBoundingClientRect();
        const itemCenter = itemRect.top + itemRect.height / 2;
        const scrollBoxCenter = scrollBoxRect.top + scrollBoxRect.height / 2;
        const distance = Math.abs(itemCenter - scrollBoxCenter);
        const maxDistance = scrollBoxRect.height / 2;
        const proximity = Math.max(0, 1 - distance / maxDistance);
        
        // Apply dynamic scaling based on proximity to center
        const scale = 0.95 + (proximity * 0.05);
        const opacity = 0.7 + (proximity * 0.3);
        
        item.style.transform = `scale(${scale})`;
        item.style.opacity = opacity;
      });
        // Infinite loop wrap-around
        if (loopEnabled && !isLoopAdjusting) {
          const st = scrollBox.scrollTop;
          const threshold = 2; // small tolerance
          if (st < loopStartTop - threshold) {
            isLoopAdjusting = true;
            scrollBox.scrollTop = st + loopSpan;
            isLoopAdjusting = false;
          } else if (st >= loopEndTop + threshold) {
            isLoopAdjusting = true;
            scrollBox.scrollTop = st - loopSpan;
            isLoopAdjusting = false;
          }
        }
    }
    
    let touchStartY = 0;
    let touchStartTime = 0;
    
    function handleTouchStart(e) {
      touchStartY = e.touches[0].clientY;
      touchStartTime = Date.now();
  if (screenEl) screenEl.classList.add('dragging');
      
      // Add visual feedback for touch start
      if (scrollBox) {
        scrollBox.style.transition = 'filter 0.1s ease';
        scrollBox.style.filter = 'brightness(1.05)';
      }
    }

    function handleTouchMoveDetect(e) {
      if (!e.touches || e.touches.length === 0) return;
      const y = e.touches[0].clientY;
      if (Math.abs(y - touchStartY) > DRAG_TOLERANCE) {
        if (screenEl) screenEl.classList.add('dragging');
      }
    }
    
    function handleTouchEnd(e) {
      if (!scrollBox) return;
      
      // Reset visual feedback
      scrollBox.style.transition = 'filter 0.3s ease';
      scrollBox.style.filter = '';
  if (screenEl) setTimeout(() => screenEl.classList.remove('dragging'), 120);
    }
    
    function showToast(message) {
      // Create toast notification
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.8);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 20px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: 500;
        z-index: 1000;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        pointer-events: none;
      `;
      
      document.body.appendChild(toast);
      
      // Animate in
      requestAnimationFrame(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translate(-50%, -50%) scale(1)';
      });
      
      // Animate out and remove
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translate(-50%, -50%) scale(0.8)';
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }, 2000);
    }
    
    function goHome() {
      // Direct navigation back to home
      window.location.href = '../index.html';
    }
    
    // Initialize app
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  })();
</script>
