<section id="screen-snake" class="screen">
  <div class="panel">
    <h2>Snake Game</h2>
    <div class="game-controls">
      <button id="btnSnakeEasy" class="chip">Easy</button>
      <button id="btnSnakeHard" class="chip">Hard</button>
      <button id="btnSnakeStart" class="chip primary">Start Game</button>
      <button id="btnHome" class="chip">Home</button>
    </div>
    <canvas id="snakeCanvas"></canvas>
    <div class="game-info">
      <span>Score: <span id="snakeScore">0</span></span>
      <span>High Score: <span id="snakeHighScore">0</span></span>
    </div>
  </div>
</section>

<style>
  /* Snake Game Specific Styles - All scoped to #screen-snake */
  #screen-snake {
    display: flex;
    flex-direction: column;
    height: 100%;
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
    color: white;
    font-family: 'Courier New', monospace;
    padding: 20px;
  }
  
  #screen-snake .panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
  }
  
  #screen-snake h2 {
    font-size: 2.5em;
    margin: 0;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    text-align: center;
  }
  
  #screen-snake .game-controls {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
    margin: 20px 0;
  }
  
  #screen-snake .chip {
    padding: 12px 24px;
    border: 2px solid rgba(255,255,255,0.3);
    border-radius: 25px;
    background: rgba(255,255,255,0.1);
    color: white;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-family: inherit;
  }
  
  #screen-snake .chip:hover {
    background: rgba(255,255,255,0.2);
    border-color: rgba(255,255,255,0.5);
    transform: translateY(-2px);
  }
  
  #screen-snake .chip.primary {
    background: #4CAF50;
    border-color: #4CAF50;
  }
  
  #screen-snake .chip.primary:hover {
    background: #45a049;
    transform: translateY(-2px);
  }
  
  #screen-snake #snakeCanvas {
    width: 100%;
    max-width: min(520px, 90vw);
    height: clamp(300px, 50vh, 520px);
    background: #111418;
    border-radius: 10px;
    border: 2px solid rgba(255,255,255,0.1);
    box-shadow: 0 8px 24px rgba(0,0,0,0.3);
    touch-action: none; /* Prevent scrolling on touch */
    user-select: none; /* Prevent text selection */
  }
  
  #screen-snake .game-info {
    display: flex;
    justify-content: space-between;
    margin: 20px 0;
    font-size: 18px;
    font-weight: bold;
    flex-wrap: wrap;
    gap: 15px;
  }
  
  #screen-snake .game-info span {
    background: rgba(255,255,255,0.1);
    padding: 8px 16px;
    border-radius: 20px;
    border: 1px solid rgba(255,255,255,0.2);
  }
</style>

<script>
  (function() {
    'use strict';
    
    // Game state
    let snake = [];
    let food = {};
    let direction = 'right';
    let gameLoop = null;
    let score = 0;
    let highScore = 0;
    let gameSpeed = 150; // Easy mode
    let isGameRunning = false;
    
    // Canvas setup
    let canvas, ctx;
    const gridSize = 20;
    let canvasSize = 400;
    let gridWidth = 20;
    let gridHeight = 20;
    
    function initApp() {
      setupCanvas();
      setupEventListeners();
      loadHighScore();
      drawGame();
    }
    
    function setupCanvas() {
      canvas = document.querySelector('#snakeCanvas');
      ctx = canvas.getContext('2d');
      
      // Set canvas size based on CSS dimensions but ensure it's divisible by gridSize
      const rect = canvas.getBoundingClientRect();
      const idealSize = Math.min(rect.width, rect.height);
      
      // Make sure canvas size is divisible by gridSize for perfect grid alignment
      canvasSize = Math.floor(idealSize / gridSize) * gridSize;
      canvas.width = canvasSize;
      canvas.height = canvasSize;
      
      // Calculate grid dimensions
      gridWidth = canvasSize / gridSize;
      gridHeight = canvasSize / gridSize;
      
      console.log(`Canvas: ${canvasSize}x${canvasSize}, Grid: ${gridWidth}x${gridHeight}`);
      
      // Initialize snake in center of grid
      const centerX = Math.floor(gridWidth / 2);
      const centerY = Math.floor(gridHeight / 2);
      
      snake = [
        {x: centerX, y: centerY},
        {x: centerX - 1, y: centerY},
        {x: centerX - 2, y: centerY}
      ];
      
      // Initialize food
      generateFood();
    }
    
    function setupEventListeners() {
      const container = document.querySelector('#screen-snake');
      
      // Game control buttons
      container.addEventListener('click', function(e) {
        if (e.target.id === 'btnSnakeEasy') {
          setDifficulty('easy');
        } else if (e.target.id === 'btnSnakeHard') {
          setDifficulty('hard');
        } else if (e.target.id === 'btnSnakeStart') {
          if (isGameRunning) {
            stopGame();
          } else {
            startGame();
          }
        } else if (e.target.id === 'btnHome') {
          goHome();
        }
      });
      
      // Keyboard controls
      document.addEventListener('keydown', handleKeyPress);
      
      // Window resize handler
      window.addEventListener('resize', function() {
        // Debounce resize events
        clearTimeout(this.resizeTimeout);
        this.resizeTimeout = setTimeout(() => {
          const wasRunning = isGameRunning;
          if (wasRunning) stopGame();
          setupCanvas();
          drawGame();
          if (wasRunning) startGame();
        }, 250);
      });
      
      // Touch controls for mobile - improved sensitivity
      let touchStartX = 0;
      let touchStartY = 0;
      let minSwipeDistance = 30; // Minimum distance for a swipe
      
      canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }, { passive: false });
      
      canvas.addEventListener('touchend', function(e) {
        e.preventDefault();
        if (!isGameRunning) return; // Only respond to touches during game
        
        const touch = e.changedTouches[0];
        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;
        
        // Check if swipe is long enough
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (distance < minSwipeDistance) return;
        
        // Determine swipe direction
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          // Horizontal swipe
          if (deltaX > 0 && direction !== 'left') {
            direction = 'right';
          } else if (deltaX < 0 && direction !== 'right') {
            direction = 'left';
          }
        } else {
          // Vertical swipe
          if (deltaY > 0 && direction !== 'up') {
            direction = 'down';
          } else if (deltaY < 0 && direction !== 'down') {
            direction = 'up';
          }
        }
      }, { passive: false });
    }
    
    function handleKeyPress(e) {
      switch(e.key) {
        case 'ArrowUp':
          if (direction !== 'down') direction = 'up';
          break;
        case 'ArrowDown':
          if (direction !== 'up') direction = 'down';
          break;
        case 'ArrowLeft':
          if (direction !== 'right') direction = 'left';
          break;
        case 'ArrowRight':
          if (direction !== 'left') direction = 'right';
          break;
        case ' ':
          if (isGameRunning) stopGame();
          else startGame();
          break;
      }
    }
    
    function setDifficulty(level) {
      if (level === 'easy') {
        gameSpeed = 150;
        document.querySelector('#btnSnakeEasy').classList.add('primary');
        document.querySelector('#btnSnakeHard').classList.remove('primary');
      } else {
        gameSpeed = 80;
        document.querySelector('#btnSnakeHard').classList.add('primary');
        document.querySelector('#btnSnakeEasy').classList.remove('primary');
      }
      
      if (isGameRunning) {
        stopGame();
        startGame();
      }
    }
    
    function startGame() {
      if (isGameRunning) return;
      
      isGameRunning = true;
      document.querySelector('#btnSnakeStart').textContent = 'Stop Game';
      document.querySelector('#btnSnakeStart').classList.add('primary');
      
      gameLoop = setInterval(updateGame, gameSpeed);
    }
    
    function stopGame() {
      if (!isGameRunning) return;
      
      isGameRunning = false;
      document.querySelector('#btnSnakeStart').textContent = 'Start Game';
      document.querySelector('#btnSnakeStart').classList.remove('primary');
      
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
    }
    
    function updateGame() {
      // Move snake
      const head = {x: snake[0].x, y: snake[0].y};
      
      switch(direction) {
        case 'up': head.y--; break;
        case 'down': head.y++; break;
        case 'left': head.x--; break;
        case 'right': head.x++; break;
      }
      
      // Check collision with walls
      if (head.x < 0 || head.x >= gridWidth || 
          head.y < 0 || head.y >= gridHeight) {
        gameOver();
        return;
      }
      
      // Check collision with self
      for (let i = 0; i < snake.length; i++) {
        if (snake[i].x === head.x && snake[i].y === head.y) {
          gameOver();
          return;
        }
      }
      
      // Check collision with food
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        updateScore();
        generateFood();
      } else {
        snake.pop(); // Remove tail if no food eaten
      }
      
      snake.unshift(head); // Add new head
      drawGame();
    }
    
    function generateFood() {
      do {
        food = {
          x: Math.floor(Math.random() * gridWidth),
          y: Math.floor(Math.random() * gridHeight)
        };
      } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
    }
    
    function drawGame() {
      // Clear canvas
      ctx.fillStyle = '#111418';
      ctx.fillRect(0, 0, canvasSize, canvasSize);
      
      // Draw grid lines for debugging (remove in production)
      if (false) { // Set to true for debugging
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= gridWidth; i++) {
          ctx.beginPath();
          ctx.moveTo(i * gridSize, 0);
          ctx.lineTo(i * gridSize, canvasSize);
          ctx.stroke();
        }
        for (let i = 0; i <= gridHeight; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * gridSize);
          ctx.lineTo(canvasSize, i * gridSize);
          ctx.stroke();
        }
      }
      
      // Draw snake
      snake.forEach((segment, index) => {
        if (index === 0) {
          // Head - brighter color
          ctx.fillStyle = '#8BC34A';
        } else {
          // Body - slightly dimmer
          ctx.fillStyle = '#4CAF50';
        }
        
        // Ensure coordinates are within bounds
        const x = Math.max(0, Math.min(segment.x * gridSize, canvasSize - gridSize));
        const y = Math.max(0, Math.min(segment.y * gridSize, canvasSize - gridSize));
        
        ctx.fillRect(x, y, gridSize - 1, gridSize - 1);
      });
      
      // Draw food
      ctx.fillStyle = '#FF5722';
      const foodX = Math.max(0, Math.min(food.x * gridSize, canvasSize - gridSize));
      const foodY = Math.max(0, Math.min(food.y * gridSize, canvasSize - gridSize));
      ctx.fillRect(foodX, foodY, gridSize - 1, gridSize - 1);
    }
    
    function gameOver() {
      stopGame();
      
      if (score > highScore) {
        highScore = score;
        saveHighScore();
        updateScore();
      }
      
      // Reset game
      const centerX = Math.floor(gridWidth / 2);
      const centerY = Math.floor(gridHeight / 2);
      
      snake = [
        {x: centerX, y: centerY},
        {x: centerX - 1, y: centerY},
        {x: centerX - 2, y: centerY}
      ];
      direction = 'right';
      score = 0;
      updateScore();
      generateFood();
      drawGame();
      
      // Show game over message
      alert(`Game Over! Score: ${score}`);
    }
    
    function updateScore() {
      document.querySelector('#snakeScore').textContent = score;
      document.querySelector('#snakeHighScore').textContent = highScore;
    }
    
    function loadHighScore() {
      try {
        const saved = localStorage.getItem('snake-high-score');
        if (saved) {
          highScore = parseInt(saved) || 0;
          updateScore();
        }
      } catch (e) {
        console.warn('Failed to load high score:', e);
      }
    }
    
    function saveHighScore() {
      try {
        localStorage.setItem('snake-high-score', highScore.toString());
      } catch (e) {
        console.warn('Failed to save high score:', e);
      }
    }
    
    // Lifecycle management
    window.appLifecycle = {
      activate: function() {
        console.log('Snake game activated');
        if (isGameRunning) {
          // Resume game if it was running
          startGame();
        }
      },
      
      deactivate: function() {
        console.log('Snake game deactivated');
        if (isGameRunning) {
          // Pause game when switching away
          stopGame();
        }
      },
      
      cleanup: function() {
        console.log('Snake game cleanup');
        stopGame();
        // Remove event listeners
        document.removeEventListener('keydown', handleKeyPress);
      }
    };
    
    function goHome() {
      // Direct navigation back to home
      window.location.href = '../index.html';
    }
    
    // Initialize app
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  })();
</script>
