<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Game - Raspberry Pi Showcase</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #fff;
      font-family: 'Arial', sans-serif;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      touch-action: none;
      position: fixed;
    }

    .game-layout {
      display: grid;
      grid-template-columns: 1fr auto;
      height: 100vh;
      width: 100vw;
      gap: 8px;
      padding: 8px;
    }

    .game-area {
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      height: 40px;
      flex-shrink: 0;
    }

    .score-display {
      background: rgba(255, 255, 255, 0.1);
      padding: 6px 12px;
      border-radius: 15px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 14px;
      font-weight: bold;
    }

    .home-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 15px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-weight: bold;
    }

    .home-btn:hover {
      background: #c82333;
    }

    #gameCanvas {
      border: 2px solid #fff;
      background: #111;
      border-radius: 6px;
      width: 100%;
      height: calc(100vh - 60px);
      max-height: calc(100vh - 60px);
      touch-action: none;
      flex: 1;
    }

    .controls-panel {
      display: flex;
      flex-direction: column;
      width: 140px;
      gap: 8px;
      padding: 4px;
    }

    .game-controls {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .control-btn {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 8px 12px;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 11px;
      font-weight: bold;
      width: 100%;
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .control-btn.active {
      background: #4CAF50;
      border-color: #4CAF50;
    }

    .touch-controls {
      display: grid;
      grid-template-columns: repeat(3, 40px);
      grid-template-rows: repeat(3, 40px);
      gap: 4px;
      margin-top: 12px;
      justify-self: center;
    }

    .direction-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      color: white;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: manipulation;
    }

    .direction-btn:active {
      background: rgba(255, 255, 255, 0.3);
      transform: scale(0.95);
    }

    .direction-btn.up { grid-column: 2; grid-row: 1; }
    .direction-btn.left { grid-column: 1; grid-row: 2; }
    .direction-btn.pause { grid-column: 2; grid-row: 2; background: #ff9800; font-size: 12px; }
    .direction-btn.right { grid-column: 3; grid-row: 2; }
    .direction-btn.down { grid-column: 2; grid-row: 3; }

    .stats {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 8px;
      margin-top: 8px;
      font-size: 10px;
    }

    .stats div {
      margin: 3px 0;
    }

    .game-over {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .game-over.show {
      display: flex;
    }

    .game-over-content {
      background: #222;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      border: 2px solid #4CAF50;
      max-width: 280px;
    }

    .game-over h2 {
      color: #4CAF50;
      font-size: 18px;
      margin-bottom: 8px;
    }

    .final-score {
      font-size: 14px;
      margin: 8px 0;
    }

    .play-again-btn {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 15px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 12px;
      font-weight: bold;
    }

    /* 5-inch screen optimization */
    @media (max-width: 850px) and (max-height: 500px) {
      .game-layout {
        padding: 4px;
        gap: 4px;
      }
      
      .controls-panel {
        width: 100px;
      }
      
      .top-bar {
        height: 30px;
        padding: 4px 0;
      }
      
      .score-display {
        font-size: 11px;
        padding: 4px 8px;
      }
      
      .home-btn {
        font-size: 10px;
        padding: 4px 8px;
      }
      
      #gameCanvas {
        height: calc(100vh - 40px);
        max-height: calc(100vh - 40px);
      }
      
      .control-btn {
        padding: 6px 8px;
        font-size: 9px;
      }
      
      .touch-controls {
        grid-template-columns: repeat(3, 32px);
        grid-template-rows: repeat(3, 32px);
        gap: 3px;
        margin-top: 8px;
      }
      
      .direction-btn {
        font-size: 14px;
      }
      
      .direction-btn.pause {
        font-size: 10px;
      }
      
      .stats {
        padding: 6px;
        font-size: 9px;
        margin-top: 6px;
      }
    }

    @media (max-width: 600px) {
      .game-layout {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr auto;
      }
      
      .controls-panel {
        width: 100%;
        flex-direction: row;
        justify-content: space-around;
        align-items: flex-start;
        height: 80px;
      }
      
      .game-controls {
        flex-direction: row;
        gap: 8px;
      }
      
      .control-btn {
        flex: 1;
        min-width: 60px;
      }
      
      .touch-controls {
        margin-top: 0;
      }
      
      .stats {
        order: -1;
        margin-top: 0;
        margin-bottom: 8px;
        text-align: center;
      }
      
      #gameCanvas {
        height: calc(100vh - 120px);
      }
    }
  </style>
</head>
<body>
  <div class="game-layout">
    <div class="game-area">
      <div class="top-bar">
        <div class="score-display">Score: <span id="score">0</span></div>
        <button class="home-btn" onclick="goHome()">HOME</button>
      </div>
      <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls-panel">
      <div class="game-controls">
        <button class="control-btn" id="startBtn" onclick="startGame()">Start</button>
        <button class="control-btn" id="pauseBtn" onclick="togglePause()">Pause</button>
        <button class="control-btn" id="resetBtn" onclick="resetGame()">Reset</button>
      </div>

      <div class="touch-controls">
        <button class="direction-btn up" onclick="changeDirection('up')">▲</button>
        <button class="direction-btn left" onclick="changeDirection('left')">◀</button>
        <button class="direction-btn pause" onclick="togglePause()">⏸</button>
        <button class="direction-btn right" onclick="changeDirection('right')">▶</button>
        <button class="direction-btn down" onclick="changeDirection('down')">▼</button>
      </div>

      <div class="stats">
        <div>High: <span id="displayHighScore">0</span></div>
        <div>Length: <span id="snakeLength">1</span></div>
      </div>
    </div>
  </div>

  <div class="game-over" id="gameOver">
    <div class="game-over-content">
      <h2>Game Over!</h2>
      <div class="final-score">Final Score: <span id="finalScore">0</span></div>
      <div>High Score: <span id="highScore">0</span></div>
      <button class="play-again-btn" onclick="resetGame()">Play Again</button>
    </div>
  </div>

  <script>
    // Game variables
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const gameOverElement = document.getElementById('gameOver');
    const finalScoreElement = document.getElementById('finalScore');
    const highScoreElement = document.getElementById('highScore');
    const displayHighScoreElement = document.getElementById('displayHighScore');
    const snakeLengthElement = document.getElementById('snakeLength');

    // Game settings
    const gridSize = 16;
    let tileCountX, tileCountY;

    let snake = [
      {x: 10, y: 10}
    ];
    let food = {};
    let dx = 0;
    let dy = 0;
    let score = 0;
    let highScore = localStorage.getItem('snakeHighScore') || 0;
    let gameRunning = false;
    let gameLoop;

    // Initialize game
    function init() {
      // Set initial high score display
      highScoreElement.textContent = highScore;
      displayHighScoreElement.textContent = highScore;
      updateSnakeLength();
      
      // Set up canvas size for responsive display
      resizeCanvas();
      
      // Generate first food
      generateFood();
      
      // Add keyboard listeners
      document.addEventListener('keydown', handleKeyPress);
      
      // Add touch swipe listeners
      addTouchListeners();
      
      // Add resize listener
      window.addEventListener('resize', resizeCanvas);
      
      // Draw initial state
      draw();
    }

    function resizeCanvas() {
      const gameArea = document.querySelector('.game-area');
      const canvasRect = canvas.getBoundingClientRect();
      
      // Get available space
      const availableWidth = gameArea.offsetWidth - 4; // Account for borders
      const availableHeight = gameArea.offsetHeight - 50; // Account for top bar
      
      // Calculate size that fits and maintains aspect ratio
      const size = Math.min(availableWidth, availableHeight);
      
      // Make sure size is divisible by gridSize for perfect grid
      const adjustedWidth = Math.floor(availableWidth / gridSize) * gridSize;
      const adjustedHeight = Math.floor(availableHeight / gridSize) * gridSize;
      
      canvas.width = adjustedWidth;
      canvas.height = adjustedHeight;
      
      // Calculate tile counts
      tileCountX = Math.floor(adjustedWidth / gridSize);
      tileCountY = Math.floor(adjustedHeight / gridSize);
      
      // Adjust snake and food positions if canvas got smaller
      snake = snake.filter(segment => 
        segment.x < tileCountX && segment.y < tileCountY
      );
      
      if (food.x >= tileCountX || food.y >= tileCountY) {
        generateFood();
      }
      
      draw();
    }

    function generateFood() {
      food = {
        x: Math.floor(Math.random() * tileCountX),
        y: Math.floor(Math.random() * tileCountY)
      };

      // Make sure food doesn't spawn on snake
      for (let segment of snake) {
        if (segment.x === food.x && segment.y === food.y) {
          generateFood();
          return;
        }
      }
    }

    function updateSnakeLength() {
      snakeLengthElement.textContent = snake.length;
    }

    function draw() {
      // Clear canvas
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw snake
      ctx.fillStyle = '#4CAF50';
      for (let segment of snake) {
        ctx.fillRect(segment.x * gridSize + 1, segment.y * gridSize + 1, 
                     gridSize - 2, gridSize - 2);
      }

      // Draw snake head differently
      if (snake.length > 0) {
        ctx.fillStyle = '#66BB6A';
        ctx.fillRect(snake[0].x * gridSize + 1, snake[0].y * gridSize + 1, 
                     gridSize - 2, gridSize - 2);
      }

      // Draw food
      ctx.fillStyle = '#F44336';
      ctx.fillRect(food.x * gridSize + 1, food.y * gridSize + 1, 
                   gridSize - 2, gridSize - 2);

      // Draw grid (optional - lighter for better visibility)
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 0.5;
      for (let i = 0; i <= tileCountX; i++) {
        ctx.beginPath();
        ctx.moveTo(i * gridSize, 0);
        ctx.lineTo(i * gridSize, canvas.height);
        ctx.stroke();
      }
      for (let i = 0; i <= tileCountY; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * gridSize);
        ctx.lineTo(canvas.width, i * gridSize);
        ctx.stroke();
      }
    }

    function update() {
      if (!gameRunning) return;

      const head = {x: snake[0].x + dx, y: snake[0].y + dy};

      // Check wall collision
      if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
        gameOver();
        return;
      }

      // Check self collision
      for (let segment of snake) {
        if (head.x === segment.x && head.y === segment.y) {
          gameOver();
          return;
        }
      }

      snake.unshift(head);

      // Check food collision
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreElement.textContent = score;
        updateSnakeLength();
        generateFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function startGame() {
      if (gameRunning) return;
      
      gameRunning = true;
      document.getElementById('startBtn').textContent = 'Running...';
      document.getElementById('startBtn').classList.add('active');
      
      gameLoop = setInterval(update, 150);
    }

    function togglePause() {
      if (!gameRunning && snake.length > 1) return; // Don't pause if game hasn't started
      
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
        document.getElementById('pauseBtn').textContent = 'Resume';
        document.getElementById('pauseBtn').classList.add('active');
      } else if (gameRunning) {
        gameLoop = setInterval(update, 150);
        document.getElementById('pauseBtn').textContent = 'Pause';
        document.getElementById('pauseBtn').classList.remove('active');
      }
    }

    function resetGame() {
      clearInterval(gameLoop);
      gameLoop = null;
      gameRunning = false;
      
      // Reset game state
      snake = [{x: 10, y: 10}];
      dx = 0;
      dy = 0;
      score = 0;
      scoreElement.textContent = score;
      updateSnakeLength();
      
      // Reset buttons
      document.getElementById('startBtn').textContent = 'Start';
      document.getElementById('startBtn').classList.remove('active');
      document.getElementById('pauseBtn').textContent = 'Pause';
      document.getElementById('pauseBtn').classList.remove('active');
      
      // Hide game over screen
      gameOverElement.classList.remove('show');
      
      generateFood();
      draw();
    }

    function gameOver() {
      clearInterval(gameLoop);
      gameLoop = null;
      gameRunning = false;
      
      // Update high score
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('snakeHighScore', highScore);
        highScoreElement.textContent = highScore;
        displayHighScoreElement.textContent = highScore;
      }
      
      // Show game over screen
      finalScoreElement.textContent = score;
      gameOverElement.classList.add('show');
      
      // Reset buttons
      document.getElementById('startBtn').textContent = 'Start';
      document.getElementById('startBtn').classList.remove('active');
    }

    function changeDirection(direction) {
      if (!gameRunning) return;

      switch (direction) {
        case 'up':
          if (dy !== 1) { dx = 0; dy = -1; }
          break;
        case 'down':
          if (dy !== -1) { dx = 0; dy = 1; }
          break;
        case 'left':
          if (dx !== 1) { dx = -1; dy = 0; }
          break;
        case 'right':
          if (dx !== -1) { dx = 1; dy = 0; }
          break;
      }
    }

    function handleKeyPress(e) {
      switch (e.key) {
        case 'ArrowUp':
        case 'w':
          e.preventDefault();
          changeDirection('up');
          break;
        case 'ArrowDown':
        case 's':
          e.preventDefault();
          changeDirection('down');
          break;
        case 'ArrowLeft':
        case 'a':
          e.preventDefault();
          changeDirection('left');
          break;
        case 'ArrowRight':
        case 'd':
          e.preventDefault();
          changeDirection('right');
          break;
        case ' ':
          e.preventDefault();
          if (!gameRunning) {
            startGame();
          } else {
            togglePause();
          }
          break;
        case 'r':
          e.preventDefault();
          resetGame();
          break;
      }
    }

    function addTouchListeners() {
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let touchEndY = 0;

      canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
      }, { passive: false });

      canvas.addEventListener('touchend', function(e) {
        e.preventDefault();
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        handleSwipe();
      }, { passive: false });

      function handleSwipe() {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const minSwipeDistance = 30;

        if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance) {
          // Too short to be a swipe, ignore
          return;
        }

        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          // Horizontal swipe
          if (deltaX > 0) {
            changeDirection('right');
          } else {
            changeDirection('left');
          }
        } else {
          // Vertical swipe
          if (deltaY > 0) {
            changeDirection('down');
          } else {
            changeDirection('up');
          }
        }
      }
    }

    function goHome() {
      window.location.href = '../index.html';
    }

    // Initialize the game when page loads
    init();
  </script>
</body>
</html>