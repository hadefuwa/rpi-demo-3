<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Model Viewer</title>
  <link rel="stylesheet" href="../styles/base.css">
  <link rel="stylesheet" href="../styles/stl.css">
  
  <!-- Quality Detection System -->
  <script>
    // Device capability detection and quality mode selection
    (function() {
      'use strict';
      
      // Get device information
      const deviceInfo = {
        cores: navigator.hardwareConcurrency || 1,
        memory: navigator.deviceMemory || 1,
        userAgent: navigator.userAgent,
        platform: navigator.platform
      };
      
      // Try to detect GPU info if WebGL is available
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (gl) {
          deviceInfo.gpuVendor = gl.getParameter(gl.VENDOR);
          deviceInfo.gpuRenderer = gl.getParameter(gl.RENDERER);
        }
      } catch (e) {
        console.log('WebGL detection failed:', e);
      }
      
             // Determine quality mode based on device capabilities
       function determineQualityMode() {
         // Check for GPU issues in user agent or console errors
         const hasGPUIssues = deviceInfo.userAgent.includes('Mesa') || 
                             deviceInfo.userAgent.includes('llvmpipe') ||
                             deviceInfo.userAgent.includes('Software');
         
         // Pi 3B+ detection (4 cores, low memory, older GPU) - force low quality
         if (deviceInfo.cores === 4 && 
             deviceInfo.memory <= 1 && 
             deviceInfo.userAgent.includes('armv7l')) {
           return 'low';
         }
         
         // Force low quality if GPU issues detected
         if (hasGPUIssues) {
           console.log('GPU issues detected, forcing low quality mode');
           return 'low';
         }
         
         // Pi 4 detection (4 cores, more memory, better GPU)
         if (deviceInfo.cores === 4 && 
             deviceInfo.memory > 1 && 
             deviceInfo.userAgent.includes('armv7l')) {
           return 'medium';
         }
         // Pi 5 detection (4+ cores, more memory, modern GPU)
         if (deviceInfo.cores >= 4 && 
             deviceInfo.memory > 2 && 
             (deviceInfo.userAgent.includes('aarch64') || deviceInfo.userAgent.includes('armv8'))) {
           return 'high';
         }
         // Fallback based on memory
         if (deviceInfo.memory <= 1) return 'low';
         if (deviceInfo.memory <= 2) return 'medium';
         return 'high';
       }
      
      window.QUALITY_MODE = determineQualityMode();
      window.DEVICE_INFO = deviceInfo;
      
      // Apply quality mode to body when DOM is ready
      function applyQualityMode() {
        if (document.body) {
          document.body.setAttribute('data-quality-mode', window.QUALITY_MODE);
          console.log('STL Viewer Quality Mode:', window.QUALITY_MODE);
          console.log('Device Info:', deviceInfo);
        }
      }
      
      // Apply immediately if body exists, otherwise wait for DOM
      if (document.body) {
        applyQualityMode();
      } else {
        document.addEventListener('DOMContentLoaded', applyQualityMode);
      }
    })();
  </script>
</head>
<body>
  <div id="app">
    <header class="topbar">
      <h1 class="title">3D Model Viewer</h1>
      <button id="btnHome" class="chip">Home</button>
    </header>
    
    <main>
      <section id="screen-stl" class="screen active">
        <div class="container">
          <div class="panel">
            <div class="toolbar stl-models">
              <span class="chip">Models:</span>
              <button class="chip model-btn active" data-model="cad1.stl">CAD 1</button>
              <button class="chip model-btn" data-model="cad2.stl">CAD 2</button>
              <button class="chip model-btn" data-model="cad3.stl">CAD 3</button>
            </div>
            
            <div class="note">Drag to rotate • Scroll to zoom</div>
            
            <div class="stl-wrap">
              <canvas id="stlCanvas"></canvas>
              <div id="loadingIndicator" class="loading-indicator">Loading 3D model...</div>
              
              <div class="stl-controls">
                <div></div>
                <button id="btnStlUp" class="chip big">▲</button>
                <div></div>
                <button id="btnStlZoomIn" class="chip big">＋</button>
                <button id="btnStlAuto" class="chip big">Auto</button>
                
                <button id="btnStlLeft" class="chip big">◀</button>
                <button id="btnStlReset" class="chip big">Reset</button>
                <button id="btnStlRight" class="chip big">▶</button>
                <button id="btnStlZoomOut" class="chip big">－</button>
                <div></div>
                
                <div></div>
                <button id="btnStlDown" class="chip big">▼</button>
                <div></div>
                <div></div>
                <div></div>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>



<script>
  (function() {
    'use strict';
    
    let scene, camera, renderer, controls;
    let currentModel = null;
    let autoRotate = false;
    let stars = [];
    
    // Load Three.js with timeout and fallback
    function loadScript(src, fallbackSrc = null) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = () => resolve();
        script.onerror = () => {
          if (fallbackSrc) {
            console.log(`Failed to load ${src}, trying fallback...`);
            const fallbackScript = document.createElement('script');
            fallbackScript.src = fallbackSrc;
            fallbackScript.onload = () => resolve();
            fallbackScript.onerror = () => reject(new Error(`Failed to load ${src} and fallback`));
            document.head.appendChild(fallbackScript);
          } else {
            reject(new Error(`Failed to load ${src}`));
          }
        };
        
        // Add timeout
        setTimeout(() => {
          if (!script.onload) {
            script.onerror();
          }
        }, 10000); // 10 second timeout
        
        document.head.appendChild(script);
      });
    }
    
    // Load all required scripts
    async function loadDependencies() {
      try {
        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js');
        await loadScript('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js');
        await loadScript('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js');
        console.log('All Three.js dependencies loaded successfully');
        initApp();
      } catch (error) {
        console.error('Failed to load Three.js dependencies:', error);
        const loadingIndicator = document.getElementById('loadingIndicator');
        if (loadingIndicator) {
          loadingIndicator.textContent = 'Failed to load 3D libraries. Please check your internet connection.';
        }
      }
    }
    
    function initApp() {
      console.log('STL Viewer app initialized');
      setupThreeJS();
      setupEventListeners();
      loadModel('cad1.stl');
    }
    
         function setupThreeJS() {
       const canvas = document.getElementById('stlCanvas');
       
       // Scene setup
       scene = new THREE.Scene();
       
       // Camera setup
       camera = new THREE.PerspectiveCamera(75, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
       camera.position.set(0, 0, 5);
       
       // Renderer setup with quality-based settings and GPU fallbacks
       const qualityMode = window.QUALITY_MODE || 'medium';
       const rendererOptions = {
         canvas: canvas,
         alpha: true,
         powerPreference: 'low-power', // Force low-power mode for RPi
         failIfMajorPerformanceCaveat: false, // Allow software rendering
         preserveDrawingBuffer: false,
         depth: true,
         stencil: false,
         antialias: false // Disable antialiasing for better performance
       };
       
       // Try to create WebGL renderer with fallbacks
       try {
         renderer = new THREE.WebGLRenderer(rendererOptions);
         console.log('WebGL renderer created successfully');
       } catch (error) {
         console.warn('WebGL renderer failed, trying fallback options:', error);
         
         // Fallback renderer options for problematic GPUs
         const fallbackOptions = {
           canvas: canvas,
           alpha: true,
           powerPreference: 'low-power',
           failIfMajorPerformanceCaveat: false,
           preserveDrawingBuffer: false,
           depth: true,
           stencil: false,
           antialias: false,
           precision: 'lowp' // Use low precision for better compatibility
         };
         
         try {
           renderer = new THREE.WebGLRenderer(fallbackOptions);
           console.log('Fallback WebGL renderer created successfully');
         } catch (fallbackError) {
           console.error('Both WebGL renderers failed:', fallbackError);
           document.getElementById('loadingIndicator').textContent = 'WebGL not supported on this device.';
           return;
         }
       }
       
       renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
       renderer.setClearColor(0x000011, 1);
       
       // Disable shadows for all quality modes on RPi 3 to improve performance
       renderer.shadowMap.enabled = false;
       
       // Set renderer info for debugging
       console.log('Renderer:', renderer.getContext().getParameter(renderer.getContext().RENDERER));
       console.log('Vendor:', renderer.getContext().getParameter(renderer.getContext().VENDOR));
      
      // Controls setup
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = qualityMode === 'low' ? 0.1 : 0.05;
      controls.enableZoom = true;
      controls.enablePan = true;
      
      // Create starfield background based on quality
      createStarfield();
      
             // Lighting setup - simplified for RPi 3 compatibility
       const ambientLight = new THREE.AmbientLight(0x404040, 0.8); // Increased ambient light
       scene.add(ambientLight);
       
       const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
       directionalLight.position.set(10, 10, 5);
       directionalLight.castShadow = false; // Disable shadows for better performance
       scene.add(directionalLight);
       
       // Only add point light for medium and high quality
       if (qualityMode !== 'low') {
         const pointLight = new THREE.PointLight(0x4444ff, 0.3, 100);
         pointLight.position.set(-10, -10, -10);
         scene.add(pointLight);
       }
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
      
      // Start render loop
      animate();
    }
    
    function createStarfield() {
      const qualityMode = window.QUALITY_MODE || 'medium';
      
      // Adjust star count based on quality mode
      let starCount, coloredStarCount;
      switch (qualityMode) {
        case 'low':
          starCount = 100;
          coloredStarCount = 25;
          break;
        case 'medium':
          starCount = 500;
          coloredStarCount = 100;
          break;
        case 'high':
          starCount = 2000;
          coloredStarCount = 500;
          break;
        default:
          starCount = 500;
          coloredStarCount = 100;
      }
      
      // Create main starfield
      const starGeometry = new THREE.BufferGeometry();
      const starPositions = new Float32Array(starCount * 3);
      
      for (let i = 0; i < starCount * 3; i += 3) {
        starPositions[i] = (Math.random() - 0.5) * 2000;
        starPositions[i + 1] = (Math.random() - 0.5) * 2000;
        starPositions[i + 2] = (Math.random() - 0.5) * 2000;
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: qualityMode === 'low' ? 1 : 2,
        sizeAttenuation: true
      });
      
      const starField = new THREE.Points(starGeometry, starMaterial);
      scene.add(starField);
      stars.push(starField);
      
      // Add colored stars only for medium and high quality
      if (qualityMode !== 'low') {
        const coloredStarGeometry = new THREE.BufferGeometry();
        const coloredStarPositions = new Float32Array(coloredStarCount * 3);
        
        for (let i = 0; i < coloredStarCount * 3; i += 3) {
          coloredStarPositions[i] = (Math.random() - 0.5) * 1500;
          coloredStarPositions[i + 1] = (Math.random() - 0.5) * 1500;
          coloredStarPositions[i + 2] = (Math.random() - 0.5) * 1500;
        }
        
        coloredStarGeometry.setAttribute('position', new THREE.BufferAttribute(coloredStarPositions, 3));
        
        const coloredStarMaterial = new THREE.PointsMaterial({
          color: 0x4488ff,
          size: qualityMode === 'high' ? 3 : 2,
          sizeAttenuation: true
        });
        
        const coloredStarField = new THREE.Points(coloredStarGeometry, coloredStarMaterial);
        scene.add(coloredStarField);
        stars.push(coloredStarField);
      }
    }
    
    function loadModel(filename) {
      const loadingIndicator = document.getElementById('loadingIndicator');
      loadingIndicator.style.display = 'block';
      loadingIndicator.textContent = 'Loading 3D model...';
      
      // Remove current model
      if (currentModel) {
        scene.remove(currentModel);
      }
      
      const loader = new THREE.STLLoader();
      loader.load(
        `../assets/${filename}`,
        function(geometry) {
          // Create material with quality-based settings
          const qualityMode = window.QUALITY_MODE || 'medium';
          const materialOptions = {
            color: 0x6bcbef,
            shininess: qualityMode === 'low' ? 50 : 100,
            specular: qualityMode === 'low' ? 0x111111 : 0x222222
          };
          
          const material = new THREE.MeshPhongMaterial(materialOptions);
          
                     // Create mesh
           currentModel = new THREE.Mesh(geometry, material);
           
           // Disable shadows for all quality modes to improve performance on RPi 3
           currentModel.castShadow = false;
           currentModel.receiveShadow = false;
          
          // Center and scale the model
          geometry.computeBoundingBox();
          const box = geometry.boundingBox;
          const center = box.getCenter(new THREE.Vector3());
          geometry.translate(-center.x, -center.y, -center.z);
          
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 2 / maxDim;
          currentModel.scale.setScalar(scale);
          
          scene.add(currentModel);
          loadingIndicator.style.display = 'none';
          
          console.log(`Loaded model: ${filename} with quality mode: ${qualityMode}`);
        },
        function(progress) {
          if (progress.total > 0) {
            const percent = Math.round(progress.loaded / progress.total * 100);
            loadingIndicator.textContent = `Loading 3D model... ${percent}%`;
          }
        },
        function(error) {
          console.error('Error loading STL:', error);
          loadingIndicator.textContent = 'Error loading model. Please try again.';
          setTimeout(() => {
            loadingIndicator.style.display = 'none';
          }, 3000);
        }
      );
    }
    
    function setupEventListeners() {
      // Model selection buttons
      document.querySelectorAll('.model-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          loadModel(this.dataset.model);
        });
      });
      
      // Control buttons
      document.getElementById('btnStlUp').addEventListener('click', () => rotateModel(0.1, 0));
      document.getElementById('btnStlDown').addEventListener('click', () => rotateModel(-0.1, 0));
      document.getElementById('btnStlLeft').addEventListener('click', () => rotateModel(0, 0.1));
      document.getElementById('btnStlRight').addEventListener('click', () => rotateModel(0, -0.1));
      document.getElementById('btnStlZoomIn').addEventListener('click', () => zoomCamera(-0.5));
      document.getElementById('btnStlZoomOut').addEventListener('click', () => zoomCamera(0.5));
      document.getElementById('btnStlReset').addEventListener('click', resetView);
      document.getElementById('btnStlAuto').addEventListener('click', toggleAutoRotate);
      document.getElementById('btnHome').addEventListener('click', goHome);
    }
    
    function rotateModel(x, y) {
      if (currentModel) {
        currentModel.rotation.x += x;
        currentModel.rotation.y += y;
      }
    }
    
    function zoomCamera(delta) {
      camera.position.multiplyScalar(1 + delta);
      camera.updateProjectionMatrix();
    }
    
    function resetView() {
      camera.position.set(0, 0, 5);
      controls.reset();
      if (currentModel) {
        currentModel.rotation.set(0, 0, 0);
      }
    }
    
    function toggleAutoRotate() {
      autoRotate = !autoRotate;
      const btn = document.getElementById('btnStlAuto');
      btn.textContent = autoRotate ? 'Stop Auto' : 'Auto';
      btn.classList.toggle('active', autoRotate);
    }
    
    function onWindowResize() {
      const canvas = document.getElementById('stlCanvas');
      camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Auto rotate model
      if (autoRotate && currentModel) {
        currentModel.rotation.y += 0.01;
      }
      
      // Animate stars based on quality mode
      const qualityMode = window.QUALITY_MODE || 'medium';
      if (qualityMode !== 'low') {
        stars.forEach((starField, index) => {
          starField.rotation.y += 0.0005 * (index + 1);
        });
      }
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    function goHome() {
      window.location.href = '../index.html';
    }
    
    // Start loading dependencies when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadDependencies);
    } else {
      loadDependencies();
    }
  })();
</script>
</body>
</html>
