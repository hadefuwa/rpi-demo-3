<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Model Viewer</title>
  <link rel="stylesheet" href="../styles/base.css">
  <link rel="stylesheet" href="../styles/stl.css">
  
  <!-- Quality Detection System -->
  <script>
    // Device capability detection and quality mode selection
    (function() {
      'use strict';
      
      // Get device information
      const deviceInfo = {
        cores: navigator.hardwareConcurrency || 1,
        memory: navigator.deviceMemory || 1,
        userAgent: navigator.userAgent,
        platform: navigator.platform
      };
      
      // Try to detect GPU info if WebGL is available
      try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (gl) {
          deviceInfo.gpuVendor = gl.getParameter(gl.VENDOR);
          deviceInfo.gpuRenderer = gl.getParameter(gl.RENDERER);
        }
      } catch (e) {
        console.log('WebGL detection failed:', e);
      }
      
             // Determine quality mode based on device capabilities
       function determineQualityMode() {
         // Enhanced RPi detection patterns
         const userAgent = deviceInfo.userAgent.toLowerCase();
         const isRaspberryPi = userAgent.includes('armv7l') || 
                              userAgent.includes('aarch64') || 
                              userAgent.includes('armv8') ||
                              userAgent.includes('linux arm') ||
                              deviceInfo.platform.toLowerCase().includes('arm');
         
         // Check for GPU issues in user agent or renderer info
         const hasGPUIssues = userAgent.includes('mesa') || 
                             userAgent.includes('llvmpipe') ||
                             userAgent.includes('software') ||
                             (deviceInfo.gpuRenderer && deviceInfo.gpuRenderer.toLowerCase().includes('llvmpipe'));
         
         // RPi 3B+ and older detection - force very low quality
         if (isRaspberryPi && deviceInfo.cores <= 4 && deviceInfo.memory <= 1) {
           console.log('RPi 3B+ or older detected, using minimal quality mode');
           return 'low';
         }
         
         // RPi 4 detection - moderate quality 
         if (isRaspberryPi && deviceInfo.cores === 4 && deviceInfo.memory > 1 && deviceInfo.memory <= 4) {
           console.log('RPi 4 detected, using medium quality mode');
           return 'medium';
         }
         
         // RPi 5 detection - better quality
         if (isRaspberryPi && (deviceInfo.cores > 4 || deviceInfo.memory > 4)) {
           console.log('RPi 5 detected, using high quality mode');
           return 'high';
         }
         
         // Force low quality if GPU issues detected on any device
         if (hasGPUIssues) {
           console.log('GPU issues detected, forcing low quality mode');
           return 'low';
         }
         
         // Generic ARM devices
         if (isRaspberryPi) {
           console.log('Generic ARM device detected, using low quality mode');
           return 'low';
         }
         
         // Fallback based on memory for non-ARM devices
         if (deviceInfo.memory <= 2) return 'low';
         if (deviceInfo.memory <= 4) return 'medium';
         return 'high';
       }
      
      window.QUALITY_MODE = determineQualityMode();
      window.DEVICE_INFO = deviceInfo;
      
      // Apply quality mode to body when DOM is ready
      function applyQualityMode() {
        if (document.body) {
          document.body.setAttribute('data-quality-mode', window.QUALITY_MODE);
          console.log('STL Viewer Quality Mode:', window.QUALITY_MODE);
          console.log('Device Info:', deviceInfo);
        }
      }
      
      // Apply immediately if body exists, otherwise wait for DOM
      if (document.body) {
        applyQualityMode();
      } else {
        document.addEventListener('DOMContentLoaded', applyQualityMode);
      }
    })();
  </script>
  
  <style>
    /* STL Viewer Custom Styles */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none; /* Prevent default touch behaviors */
    }
    
    /* Header styling */
    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      position: relative;
      z-index: 1000;
    }
    
    .topbar .title {
      font-size: 1.2rem;
      margin: 0;
    }
    
    .model-selector {
      display: flex;
      gap: 8px;
      flex: 1;
      justify-content: center;
    }
    
    .model-selector .chip {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .model-selector .chip:hover,
    .model-selector .chip.active {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
    }
    
    /* Prevent zoom on entire page */
    #app {
      touch-action: pan-x pan-y;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }
    
    /* Canvas container - allow 3D interactions only */
    .stl-wrap {
      position: relative;
      width: 100%;
      height: calc(100vh - 80px); /* Reduced from 120px to expand canvas */
      touch-action: none; /* Allow Three.js to handle all touch events */
    }
    
    #stlCanvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
      touch-action: none; /* Critical for proper 3D interaction */
    }
    
    /* Loading indicator */
    .loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      z-index: 100;
    }
    
    /* Simplified controls */
    .stl-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 25px;
      z-index: 10;
    }
    
    .stl-controls .chip {
      padding: 10px 15px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      touch-action: manipulation; /* Prevent zoom on button tap */
    }
    
    .stl-controls .chip:hover,
    .stl-controls .chip.active {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
    }
    
    .note {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-size: 0.9rem;
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .topbar {
        flex-direction: column;
        gap: 10px;
        padding: 10px;
      }
      
      .model-selector {
        order: 2;
      }
      
      .topbar .title {
        order: 1;
        font-size: 1rem;
      }
      
      #btnHome {
        order: 3;
      }
      
      .stl-wrap {
        height: calc(100vh - 120px); /* Reduced padding for mobile */
      }
      
      .stl-controls {
        bottom: 10px;
        gap: 5px;
        padding: 8px;
      }
      
      .stl-controls .chip {
        padding: 8px 12px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header class="topbar">
      <h1 class="title">3D Model Viewer</h1>
      <div class="model-selector">
        <button class="chip model-btn active" data-model="cad1.stl">CAD 1</button>
        <button class="chip model-btn" data-model="cad2.stl">CAD 2</button>
        <button class="chip model-btn" data-model="cad3.stl">CAD 3</button>
      </div>
      <button id="btnHome" class="chip">Home</button>
    </header>
    
    <main>
      <section id="screen-stl" class="screen active">
        <div class="container" style="padding: 0; margin: 0;">
          <div class="panel" style="padding: var(--spacing-xs); margin: 0;">
            <div class="note">Drag to rotate • Scroll to zoom</div>
            
            <div class="stl-wrap">
              <canvas id="stlCanvas"></canvas>
              <div id="loadingIndicator" class="loading-indicator">Loading 3D model...</div>
              
              <div class="stl-controls">
                <button id="btnStlZoomIn" class="chip big">＋</button>
                <button id="btnStlAuto" class="chip big">Auto</button>
                <button id="btnStlReset" class="chip big">Reset</button>
                <button id="btnStlZoomOut" class="chip big">－</button>
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>



<script>
  (function() {
    'use strict';
    
    let scene, camera, renderer, controls;
    let currentModel = null;
    let autoRotate = false;
    let stars = [];
    
    // Load Three.js with timeout and fallback
    function loadScript(src, fallbackSrc = null, localFallback = null) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = () => {
          console.log(`Successfully loaded: ${src}`);
          resolve();
        };
        script.onerror = () => {
          console.warn(`Failed to load ${src}`);
          if (fallbackSrc) {
            console.log(`Trying fallback: ${fallbackSrc}`);
            const fallbackScript = document.createElement('script');
            fallbackScript.src = fallbackSrc;
            fallbackScript.onload = () => {
              console.log(`Successfully loaded fallback: ${fallbackSrc}`);
              resolve();
            };
            fallbackScript.onerror = () => {
              if (localFallback) {
                console.log(`Trying local fallback: ${localFallback}`);
                const localScript = document.createElement('script');
                localScript.src = localFallback;
                localScript.onload = () => {
                  console.log(`Successfully loaded local fallback: ${localFallback}`);
                  resolve();
                };
                localScript.onerror = () => reject(new Error(`All fallbacks failed for ${src}`));
                document.head.appendChild(localScript);
              } else {
                reject(new Error(`Failed to load ${src} and fallback`));
              }
            };
            document.head.appendChild(fallbackScript);
          } else {
            reject(new Error(`Failed to load ${src}`));
          }
        };
        
        // Add timeout for RPi slow connections
        setTimeout(() => {
          if (!script.onload.called) {
            console.warn(`Timeout loading ${src}, triggering error handler`);
            script.onerror();
          }
        }, 15000); // 15 second timeout for RPi
        
        document.head.appendChild(script);
      });
    }
    
    // Load all required scripts
    async function loadDependencies() {
      const loadingIndicator = document.getElementById('loadingIndicator');
      
      try {
        loadingIndicator.textContent = 'Loading 3D libraries...';
        
        // Try multiple CDNs for better RPi compatibility
        await loadScript(
          'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
          'https://unpkg.com/three@0.128.0/build/three.min.js',
          'https://cdn.skypack.dev/three@0.128.0'
        );
        
        loadingIndicator.textContent = 'Loading STL loader...';
        await loadScript(
          'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js',
          'https://unpkg.com/three@0.128.0/examples/js/loaders/STLLoader.js'
        );
        
        loadingIndicator.textContent = 'Loading orbit controls...';
        await loadScript(
          'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js',
          'https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js'
        );
        
        console.log('All Three.js dependencies loaded successfully');
        loadingIndicator.textContent = 'Initializing 3D viewer...';
        
        // Add small delay for RPi processing
        setTimeout(() => {
          initApp();
        }, 500);
        
      } catch (error) {
        console.error('Failed to load Three.js dependencies:', error);
        loadingIndicator.innerHTML = `
          <div style="text-align: center;">
            <div>Failed to load 3D libraries</div>
            <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.7;">
              Please check your internet connection and try refreshing the page
            </div>
            <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #6bcbef; border: none; border-radius: 4px; color: black; cursor: pointer;">
              Retry
            </button>
          </div>
        `;
      }
    }
    
    function initApp() {
      console.log('STL Viewer app initialized');
      setupThreeJS();
      setupEventListeners();
      loadModel('cad1.stl');
    }
    
         function setupThreeJS() {
       const canvas = document.getElementById('stlCanvas');
       
       // Scene setup
       scene = new THREE.Scene();
       
       // Camera setup
       camera = new THREE.PerspectiveCamera(75, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
       camera.position.set(0, 0, 5);
       
       // Renderer setup with quality-based settings and GPU fallbacks
       const qualityMode = window.QUALITY_MODE || 'medium';
       console.log(`Setting up renderer for quality mode: ${qualityMode}`);
       
       // Base renderer options optimized for RPi
       const baseOptions = {
         canvas: canvas,
         alpha: true,
         powerPreference: 'low-power', // Force low-power mode for RPi
         failIfMajorPerformanceCaveat: false, // Allow software rendering
         preserveDrawingBuffer: false,
         depth: true,
         stencil: false,
         antialias: false, // Disable antialiasing for better performance
         precision: 'lowp', // Use low precision for better compatibility
         logarithmicDepthBuffer: false // Disable for better compatibility
       };
       
       // Try multiple renderer configurations
       const rendererConfigs = [
         // First try: standard WebGL
         { ...baseOptions },
         // Second try: force WebGL 1.0 for better compatibility
         { ...baseOptions, context: 'webgl' },
         // Third try: experimental WebGL
         { ...baseOptions, context: 'experimental-webgl' },
         // Fourth try: minimal options
         { canvas: canvas, alpha: false, powerPreference: 'low-power', failIfMajorPerformanceCaveat: false }
       ];
       
       let rendererCreated = false;
       
       for (let i = 0; i < rendererConfigs.length && !rendererCreated; i++) {
         try {
           console.log(`Attempting renderer config ${i + 1}`);
           renderer = new THREE.WebGLRenderer(rendererConfigs[i]);
           console.log(`WebGL renderer created successfully with config ${i + 1}`);
           rendererCreated = true;
         } catch (error) {
           console.warn(`Renderer config ${i + 1} failed:`, error);
         }
       }
       
       if (!rendererCreated) {
         console.error('All WebGL renderer configurations failed');
         const loadingIndicator = document.getElementById('loadingIndicator');
         loadingIndicator.innerHTML = `
           <div style="text-align: center;">
             <div>WebGL not supported on this device</div>
             <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.7;">
               Your browser or hardware doesn't support 3D graphics
             </div>
             <button onclick="window.location.href='../index.html'" style="margin-top: 10px; padding: 8px 16px; background: #6bcbef; border: none; border-radius: 4px; color: black; cursor: pointer;">
               Back to Home
             </button>
           </div>
         `;
         return;
       }
       
       renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
       renderer.setClearColor(0x000011, 1);
       
       // Disable shadows for all quality modes on RPi 3 to improve performance
       renderer.shadowMap.enabled = false;
       
       // Set renderer info for debugging
       console.log('Renderer:', renderer.getContext().getParameter(renderer.getContext().RENDERER));
       console.log('Vendor:', renderer.getContext().getParameter(renderer.getContext().VENDOR));
      
       // Controls setup
       controls = new THREE.OrbitControls(camera, renderer.domElement);
       controls.enableDamping = true;
       controls.dampingFactor = qualityMode === 'low' ? 0.1 : 0.05;
       controls.enableZoom = true;
       controls.enablePan = true;
       
       // Prevent controls from interfering with page scrolling
       controls.domElement.style.touchAction = 'none';
       
       // Create starfield background based on quality
       createStarfield();
      
             // Lighting setup - simplified for RPi 3 compatibility
       const ambientLight = new THREE.AmbientLight(0x404040, 0.8); // Increased ambient light
       scene.add(ambientLight);
       
       const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
       directionalLight.position.set(10, 10, 5);
       directionalLight.castShadow = false; // Disable shadows for better performance
       scene.add(directionalLight);
       
       // Only add point light for medium and high quality
       if (qualityMode !== 'low') {
         const pointLight = new THREE.PointLight(0x4444ff, 0.3, 100);
         pointLight.position.set(-10, -10, -10);
         scene.add(pointLight);
       }
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
      
      // Start render loop
      animate();
    }
    
    function createStarfield() {
      const qualityMode = window.QUALITY_MODE || 'medium';
      
      // Adjust star count based on quality mode
      let starCount, coloredStarCount;
      switch (qualityMode) {
        case 'low':
          starCount = 100;
          coloredStarCount = 25;
          break;
        case 'medium':
          starCount = 500;
          coloredStarCount = 100;
          break;
        case 'high':
          starCount = 2000;
          coloredStarCount = 500;
          break;
        default:
          starCount = 500;
          coloredStarCount = 100;
      }
      
      // Create main starfield
      const starGeometry = new THREE.BufferGeometry();
      const starPositions = new Float32Array(starCount * 3);
      
      for (let i = 0; i < starCount * 3; i += 3) {
        starPositions[i] = (Math.random() - 0.5) * 2000;
        starPositions[i + 1] = (Math.random() - 0.5) * 2000;
        starPositions[i + 2] = (Math.random() - 0.5) * 2000;
      }
      
      starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
      
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: qualityMode === 'low' ? 1 : 2,
        sizeAttenuation: true
      });
      
      const starField = new THREE.Points(starGeometry, starMaterial);
      scene.add(starField);
      stars.push(starField);
      
      // Add colored stars only for medium and high quality
      if (qualityMode !== 'low') {
        const coloredStarGeometry = new THREE.BufferGeometry();
        const coloredStarPositions = new Float32Array(coloredStarCount * 3);
        
        for (let i = 0; i < coloredStarCount * 3; i += 3) {
          coloredStarPositions[i] = (Math.random() - 0.5) * 1500;
          coloredStarPositions[i + 1] = (Math.random() - 0.5) * 1500;
          coloredStarPositions[i + 2] = (Math.random() - 0.5) * 1500;
        }
        
        coloredStarGeometry.setAttribute('position', new THREE.BufferAttribute(coloredStarPositions, 3));
        
        const coloredStarMaterial = new THREE.PointsMaterial({
          color: 0x4488ff,
          size: qualityMode === 'high' ? 3 : 2,
          sizeAttenuation: true
        });
        
        const coloredStarField = new THREE.Points(coloredStarGeometry, coloredStarMaterial);
        scene.add(coloredStarField);
        stars.push(coloredStarField);
      }
    }
    
    function loadModel(filename) {
      const loadingIndicator = document.getElementById('loadingIndicator');
      loadingIndicator.style.display = 'block';
      loadingIndicator.textContent = 'Loading 3D model...';
      
      // Remove current model
      if (currentModel) {
        scene.remove(currentModel);
        // Force garbage collection hint
        if (currentModel.geometry) currentModel.geometry.dispose();
        if (currentModel.material) currentModel.material.dispose();
        currentModel = null;
      }
      
      const loader = new THREE.STLLoader();
      
      // Add timeout for RPi slow loading
      const loadTimeout = setTimeout(() => {
        console.warn('Model loading timeout');
        loadingIndicator.innerHTML = `
          <div style="text-align: center;">
            <div>Loading taking longer than expected...</div>
            <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.7;">
              Please wait or try a different model
            </div>
          </div>
        `;
      }, 30000); // 30 second timeout
      
      loader.load(
        `../assets/${filename}`,
        function(geometry) {
          clearTimeout(loadTimeout);
          
          try {
                       // Create material with quality-based settings
             const qualityMode = window.QUALITY_MODE || 'medium';
             const materialOptions = {
               color: 0xffffff, // White color for better visibility
               shininess: qualityMode === 'low' ? 30 : (qualityMode === 'medium' ? 50 : 100),
               specular: qualityMode === 'low' ? 0x111111 : (qualityMode === 'medium' ? 0x222222 : 0x333333),
               flatShading: qualityMode === 'low' // Use flat shading for better performance on low-end devices
             };
            
            const material = new THREE.MeshPhongMaterial(materialOptions);
            
                       // Create mesh
             currentModel = new THREE.Mesh(geometry, material);
             
             // Disable shadows for all quality modes to improve performance on RPi
             currentModel.castShadow = false;
             currentModel.receiveShadow = false;
            
            // Center and scale the model
            geometry.computeBoundingBox();
            const box = geometry.boundingBox;
            const center = box.getCenter(new THREE.Vector3());
            geometry.translate(-center.x, -center.y, -center.z);
            
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 2 / maxDim;
            currentModel.scale.setScalar(scale);
            
            scene.add(currentModel);
            loadingIndicator.style.display = 'none';
            
            console.log(`Successfully loaded model: ${filename} with quality mode: ${qualityMode}`);
          } catch (error) {
            console.error('Error processing model geometry:', error);
            loadingIndicator.innerHTML = `
              <div style="text-align: center;">
                <div>Error processing 3D model</div>
                <button onclick="loadModel('${filename}')" style="margin-top: 10px; padding: 8px 16px; background: #6bcbef; border: none; border-radius: 4px; color: black; cursor: pointer;">
                  Retry
                </button>
              </div>
            `;
          }
        },
        function(progress) {
          if (progress.total > 0) {
            const percent = Math.round(progress.loaded / progress.total * 100);
            loadingIndicator.textContent = `Loading 3D model... ${percent}%`;
          }
        },
        function(error) {
          clearTimeout(loadTimeout);
          console.error('Error loading STL:', error);
          loadingIndicator.innerHTML = `
            <div style="text-align: center;">
              <div>Error loading model: ${filename}</div>
              <div style="font-size: 0.9em; margin-top: 10px; opacity: 0.7;">
                Network error or file not found
              </div>
              <button onclick="loadModel('${filename}')" style="margin-top: 10px; padding: 8px 16px; background: #6bcbef; border: none; border-radius: 4px; color: black; cursor: pointer;">
                Retry
              </button>
            </div>
          `;
        }
      );
    }
    
    function setupEventListeners() {
      // Model selection buttons
      document.querySelectorAll('.model-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.model-btn').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          loadModel(this.dataset.model);
        });
      });
      
      // Simplified control buttons (removed arrow controls)
      document.getElementById('btnStlZoomIn').addEventListener('click', () => zoomCamera(-0.5));
      document.getElementById('btnStlZoomOut').addEventListener('click', () => zoomCamera(0.5));
      document.getElementById('btnStlReset').addEventListener('click', resetView);
      document.getElementById('btnStlAuto').addEventListener('click', toggleAutoRotate);
      document.getElementById('btnHome').addEventListener('click', goHome);
      
      // Prevent default touch behaviors on the entire app
      document.addEventListener('touchstart', function(e) {
        if (e.touches.length > 1) {
          e.preventDefault();
        }
      }, { passive: false });
      
      document.addEventListener('touchmove', function(e) {
        if (e.touches.length > 1) {
          e.preventDefault();
        }
      }, { passive: false });
    }
    
    function zoomCamera(delta) {
      camera.position.multiplyScalar(1 + delta);
      camera.updateProjectionMatrix();
    }
    
    function resetView() {
      camera.position.set(0, 0, 5);
      controls.reset();
      if (currentModel) {
        currentModel.rotation.set(0, 0, 0);
      }
    }
    
    function toggleAutoRotate() {
      autoRotate = !autoRotate;
      const btn = document.getElementById('btnStlAuto');
      btn.textContent = autoRotate ? 'Stop Auto' : 'Auto';
      btn.classList.toggle('active', autoRotate);
    }
    
    function onWindowResize() {
      const canvas = document.getElementById('stlCanvas');
      camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Auto rotate model
      if (autoRotate && currentModel) {
        currentModel.rotation.y += 0.01;
      }
      
      // Animate stars based on quality mode
      const qualityMode = window.QUALITY_MODE || 'medium';
      if (qualityMode !== 'low') {
        stars.forEach((starField, index) => {
          starField.rotation.y += 0.0005 * (index + 1);
        });
      }
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    function goHome() {
      window.location.href = '../index.html';
    }
    
    // Start loading dependencies when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadDependencies);
    } else {
      loadDependencies();
    }
  })();
</script>
</body>
</html>
