<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Basic 3D Classroom – Fixed Model Anchors</title>
  <style>
    :root { --ui-bg:#0f1115; --ui-fg:#e6e6e6; --ui-muted:#8b8d93; --ui-accent:#6aa0ff; }
    html, body { height:100%; margin:0; }
    body { background:#0b0d12; color:var(--ui-fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; }
    .app { position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr; }

    .toolbar { display:flex; flex-wrap:wrap; gap:.5rem; align-items:center; padding:.6rem .8rem; background:rgba(15,17,21,.9); backdrop-filter: blur(8px); border-bottom:1px solid rgba(255,255,255,.06); }
    .toolbar .group { display:flex; gap:.5rem; align-items:center; }
    .toolbar label { font-size:.9rem; color:var(--ui-muted); }
    .toolbar button { appearance:none; border:none; cursor:pointer; padding:.5rem .7rem; border-radius:10px; font-weight:600; background:#1a1e27; color:var(--ui-fg); box-shadow:0 1px 0 rgba(255,255,255,.04) inset, 0 6px 18px rgba(0,0,0,.45); }
    .toolbar button:hover { background:#232938; }
    .toolbar button.primary { background: linear-gradient(180deg, #2c73ff, #2454ff); }
    .toolbar button.primary:hover { filter:brightness(1.08); }

    .stage { position:relative; height:100%; background:#000; }
    canvas { position:absolute; inset:0; display:block; }

    .legend { position:absolute; left:12px; bottom:12px; background:rgba(0,0,0,.5); border:1px solid rgba(255,255,255,.06); border-radius:10px; padding:.6rem .7rem; font-size:.9rem; }
    .chip { display:inline-flex; gap:.35rem; align-items:center; padding:.2rem .5rem; border-radius:999px; background:#19202c; color:#cfe0ff; font-size:.78rem; margin-right:.35rem; }
  </style>
</head>
<body>
  <div class="app">
    <div class="toolbar">
      <div class="group">
        <label>Anchors</label>
        <button id="loadAll" class="primary">Load 1•2•3</button>
        <button id="clear">Clear</button>
      </div>
      <div class="group">
        <label>Swap</label>
        <button id="swap12">1↔2</button>
        <button id="swap23">2↔3</button>
        <button id="swap13">1↔3</button>
      </div>
      <div class="group">
        <button id="toggleRoom">Wireframe: Off</button>
        <button id="toggleShadows">Shadows: On</button>
        <button id="resetCam">Reset Camera</button>
      </div>
      <div class="group" style="margin-left:auto">
        <span style="color:var(--ui-muted); font-size:.9rem">Use mouse to look around • scroll to zoom</span>
      </div>
    </div>
    <div class="stage">
      <canvas id="three"></canvas>
      <div class="legend">
        <div><span class="chip">Anchor A</span> Teacher desk (front)</div>
        <div><span class="chip">Anchor B</span> Side shelf (right wall)</div>
        <div><span class="chip">Anchor C</span> Back corner (floor)</div>
      </div>
    </div>
  </div>

  <script src="../js/three/three.standalone.js"></script>
  <script src="../js/three/GLTFLoader.js"></script>
  <script src="../js/three/OrbitControls.js"></script>
  <script>

    // ===== Config: point these at your served assets =====
    const MODEL_URLS = [
      '/assets/model1.glb',
      '/assets/model2.glb',
      '/assets/model3.glb'
    ];

    // ===== Three basics =====
    const canvas = document.getElementById('three');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0d12);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(6.5, 4.0, 8.5);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.2, 0);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI/2 - 0.05;
    controls.minDistance = 3;
    controls.maxDistance = 18;

    // Lights
    const hemi = new THREE.HemisphereLight(0xeef2ff, 0x334466, 0.9);
    scene.add(hemi);

    const key = new THREE.DirectionalLight(0xffffff, 0.9);
    key.position.set(6, 8, 6);
    key.castShadow = true;
    key.shadow.mapSize.set(1024, 1024);
    key.shadow.camera.near = 0.5; key.shadow.camera.far = 50;
    key.shadow.camera.left = -10; key.shadow.camera.right = 10; key.shadow.camera.top = 10; key.shadow.camera.bottom = -10;
    scene.add(key);

    // ===== Minimal classroom =====
    // Room size ~ 10m x 6m x 3m
    const ROOM = { w:10, d:6, h:3 };
    const room = new THREE.Group(); scene.add(room);

    // Floor
    const floorMat = new THREE.MeshStandardMaterial({ color:0x2a2e38, roughness:0.9, metalness:0.0 });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM.w, ROOM.d), floorMat);
    floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; room.add(floor);

    // Walls (simple boxes with inward normals via backSide)
    const wallMat = new THREE.MeshStandardMaterial({ color:0x1b2028, roughness:0.95, metalness:0.0, side:THREE.BackSide });
    const walls = new THREE.Mesh(new THREE.BoxGeometry(ROOM.w, ROOM.h, ROOM.d), wallMat);
    walls.position.set(0, ROOM.h/2, 0); walls.receiveShadow = true; room.add(walls);

    // Windows (simple light panels on left wall)
    const winGeo = new THREE.PlaneGeometry(1.2, 0.8);
    const winMat = new THREE.MeshBasicMaterial({ color:0x99c8ff, transparent:true, opacity:0.2 });
    const window1 = new THREE.Mesh(winGeo, winMat); window1.position.set(-ROOM.w/2+0.01, 1.6, -1.0); window1.rotation.y = Math.PI/2; room.add(window1);
    const window2 = window1.clone(); window2.position.z = 1.0; room.add(window2);

    // Teacher desk (front, near board)
    const desk = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.8, 0.7), new THREE.MeshStandardMaterial({ color:0x3b414f, roughness:0.8 }));
    desk.position.set(0, 0.4, -ROOM.d/2 + 1.2); desk.castShadow = true; desk.receiveShadow = true; room.add(desk);

    // Board (front wall)
    const board = new THREE.Mesh(new THREE.PlaneGeometry(3.0, 1.2), new THREE.MeshStandardMaterial({ color:0x24313e, roughness:0.6 }));
    board.position.set(0, 1.5, -ROOM.d/2 + 0.01); room.add(board);

    // Two rows of student tables
    const tableMat = new THREE.MeshStandardMaterial({ color:0x394354, roughness:0.85 });
    for (let row=0; row<2; row++) {
      for (let i=0; i<4; i++) {
        const t = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.75, 0.6), tableMat);
        t.position.set(-ROOM.w/2 + 1.6 + i*2.3, 0.375, -0.5 + row*1.7);
        t.castShadow = true; t.receiveShadow = true; room.add(t);
      }
    }

    // Side shelf (right wall)
    const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.2, 0.4), new THREE.MeshStandardMaterial({ color:0x2e3644, roughness:0.85 }));
    shelf.position.set(ROOM.w/2 - 0.5, 1.1, 0.5); shelf.castShadow = true; shelf.receiveShadow = true; room.add(shelf);

    // ===== Fixed anchors =====
    // A: Teacher desk top center
    const anchorA = new THREE.Object3D(); anchorA.position.set(desk.position.x, desk.position.y + 0.43, desk.position.z);
    // B: Side shelf
    const anchorB = new THREE.Object3D(); anchorB.position.set(shelf.position.x, shelf.position.y + 0.12, shelf.position.z);
    // C: Back-left floor corner
    const anchorC = new THREE.Object3D(); anchorC.position.set(-ROOM.w/2 + 0.6, 0.0, ROOM.d/2 - 0.8);
    room.add(anchorA, anchorB, anchorC);

    // Debug anchor gizmos (small cylinders)
    function gizmo(color=0x6aa0ff){
      const m = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,0.02,16), new THREE.MeshStandardMaterial({ color, emissive:0x111111 }));
      m.rotation.x = Math.PI/2; return m;
    }
    anchorA.add(gizmo(0x6aa0ff)); anchorB.add(gizmo(0xffa86a)); anchorC.add(gizmo(0x8cff6a));

    // ===== Model loading to anchors =====
    const loader = new GLTFLoader();
    const assigned = { A:null, B:null, C:null }; // track loaded roots per anchor

    async function loadToAnchor(url, anchor) {
      // Remove previous child model (leave gizmo)
      [...anchor.children].forEach(ch => { if (ch.userData?.isModel) { anchor.remove(ch); ch.traverse?.(n=>{ if(n.isMesh){ n.geometry?.dispose?.(); if(n.material?.map) n.material.map.dispose?.(); n.material?.dispose?.(); }}); } });
      const gltf = await loader.loadAsync(url);
      const root = gltf.scene || gltf.scenes?.[0];
      root.userData.isModel = true;
      // normalise scale around ~0.6m size to fit desk/shelf/floor
      const box = new THREE.Box3().setFromObject(root);
      const size = box.getSize(new THREE.Vector3()).length() || 1;
      const scale = 0.6 / size; root.scale.setScalar(scale);
      // lift slightly above surface
      box.setFromObject(root);
      const yLift = Math.max(0.02, -box.min.y * scale);
      root.position.set(0, yLift, 0);
      root.traverse(o=>{ if(o.isMesh){ o.castShadow = true; o.receiveShadow = true; } });
      anchor.add(root);
      return root;
    }

    // Buttons
    const $ = id => document.getElementById(id);
    $('loadAll').onclick = async () => {
      assigned.A = await loadToAnchor(MODEL_URLS[0], anchorA);
      assigned.B = await loadToAnchor(MODEL_URLS[1], anchorB);
      assigned.C = await loadToAnchor(MODEL_URLS[2], anchorC);
    };
    $('clear').onclick = () => {
      for (const a of [anchorA, anchorB, anchorC]) {
        [...a.children].forEach(ch => { if (ch.userData?.isModel) a.remove(ch); });
      }
      assigned.A = assigned.B = assigned.C = null;
    };

    $('swap12').onclick = async () => {
      // swap models between A and B
      const tmpA = assigned.A, tmpB = assigned.B;
      if (tmpB) assigned.A = await loadToAnchor(MODEL_URLS[MODEL_URLS.indexOf(tmpB.userData.src) ?? 1], anchorA);
      if (tmpA) assigned.B = await loadToAnchor(MODEL_URLS[MODEL_URLS.indexOf(tmpA.userData.src) ?? 0], anchorB);
    };

    $('swap23').onclick = async () => {
      const tmpB = assigned.B, tmpC = assigned.C;
      if (tmpC) assigned.B = await loadToAnchor(MODEL_URLS[MODEL_URLS.indexOf(tmpC.userData.src) ?? 2], anchorB);
      if (tmpB) assigned.C = await loadToAnchor(MODEL_URLS[MODEL_URLS.indexOf(tmpB.userData.src) ?? 1], anchorC);
    };

    $('swap13').onclick = async () => {
      const tmpA = assigned.A, tmpC = assigned.C;
      if (tmpC) assigned.A = await loadToAnchor(MODEL_URLS[MODEL_URLS.indexOf(tmpC.userData.src) ?? 2], anchorA);
      if (tmpA) assigned.C = await loadToAnchor(MODEL_URLS[MODEL_URLS.indexOf(tmpA.userData.src) ?? 0], anchorC);
    };

    // Track source on root for swaps
    const _origLoadToAnchor = loadToAnchor;
    loadToAnchor = async (url, anchor) => {
      const root = await _origLoadToAnchor(url, anchor);
      root.userData.src = url; return root;
    };

    // Toggles
    let showWire = false; $('toggleRoom').onclick = () => {
      showWire = !showWire; $('toggleRoom').textContent = `Wireframe: ${showWire ? 'On' : 'Off'}`;
      [floorMat, wallMat, tableMat].forEach(m => { m.wireframe = showWire; });
    };
    let shadowsOn = true; $('toggleShadows').onclick = () => {
      shadowsOn = !shadowsOn; $('toggleShadows').textContent = `Shadows: ${shadowsOn ? 'On' : 'Off'}`;
      renderer.shadowMap.enabled = shadowsOn; key.castShadow = shadowsOn; floor.receiveShadow = shadowsOn;
    };
    $('resetCam').onclick = () => { camera.position.set(6.5, 4.0, 8.5); controls.target.set(0,1.2,0); controls.update(); };

    // Resize
    function onResize(){
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w/h; camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    // Render loop
    function tick(){
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    onResize(); tick();
  </script>
</body>
</html>
