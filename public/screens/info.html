<!-- Disable zoom -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<section id="screen-info" class="screen">
  <img src="../assets/Matrix.png" alt="Matrix TSL" class="logo matrix-logo" />
  <button id="btnHome" class="home-button">üè†</button>
  <div class="panel">
    <h2>System Info</h2>
    <div class="visual-metrics">
      <div class="gauge-grid">
        <div class="gauge-card">
          <canvas class="gauge-canvas" id="gaugeActivity"></canvas>
          <div class="gauge-meta">
            <span class="gauge-title">Activity</span>
            <span class="gauge-value" id="gaugeActivityValue">--</span>
          </div>
        </div>
        <div class="gauge-card">
          <canvas class="gauge-canvas" id="gaugeMemory"></canvas>
          <div class="gauge-meta">
            <span class="gauge-title">Memory</span>
            <span class="gauge-value" id="gaugeMemoryValue">--</span>
          </div>
        </div>
        <div class="gauge-card">
          <canvas class="gauge-canvas" id="gaugeBattery"></canvas>
          <div class="gauge-meta">
            <span class="gauge-title">Battery</span>
            <span class="gauge-value" id="gaugeBatteryValue">--</span>
          </div>
        </div>
        <div class="gauge-card">
          <canvas class="gauge-canvas" id="gaugeNetwork"></canvas>
          <div class="gauge-meta">
            <span class="gauge-title">Network</span>
            <span class="gauge-value" id="gaugeNetworkValue">--</span>
          </div>
        </div>
      </div>
    </div>

    <div class="trend-section">
      <h3>System Performance Trends</h3>
      <div class="trend-info">
        <div class="trend-stats">
          <div class="trend-stat">
            <span class="trend-label">Peak FPS:</span>
            <span class="trend-value" id="peakFPS">--</span>
          </div>
          <div class="trend-stat">
            <span class="trend-label">Avg Memory:</span>
            <span class="trend-value" id="avgMemory">--</span>
          </div>
          <div class="trend-stat">
            <span class="trend-label">Network Speed:</span>
            <span class="trend-value" id="networkSpeed">--</span>
          </div>
          <div class="trend-stat">
            <span class="trend-label">Uptime:</span>
            <span class="trend-value" id="uptime">--</span>
          </div>
        </div>
      </div>
      <canvas class="trend-canvas" id="trendCanvas"></canvas>
    </div>

    <div class="sparkline-section">
      <h3>Mini Sparklines</h3>
      <div class="sparkline-grid">
        <div class="sparkline-card">
          <span class="sparkline-title">FPS</span>
          <canvas class="sparkline-canvas" id="sparkFPS"></canvas>
        </div>
        <div class="sparkline-card">
          <span class="sparkline-title">Memory (MB)</span>
          <canvas class="sparkline-canvas" id="sparkMem"></canvas>
        </div>
        <div class="sparkline-card">
          <span class="sparkline-title">Network (Mbps)</span>
          <canvas class="sparkline-canvas" id="sparkNet"></canvas>
        </div>
      </div>
    </div>

    <div class="info-grid">
      <div class="info-section">
        <h3>Network Information</h3>
        <div class="info-item">
          <span class="info-label">IP Address:</span>
          <span class="info-value status-good" id="ipAddress">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Network Status:</span>
          <span class="info-value status-healthy" id="networkStatus">Checking...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Connection Type:</span>
          <span class="info-value" id="connectionType">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Latency:</span>
          <span class="info-value" id="latency">Testing...</span>
        </div>
      </div>
      
      <div class="info-section">
        <h3>Device Information</h3>
        <div class="info-item">
          <span class="info-label">Platform:</span>
          <span class="info-value" id="platform">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">User Agent:</span>
          <span class="info-value" id="userAgent">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Language:</span>
          <span class="info-value" id="language">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Cookies Enabled:</span>
          <span class="info-value status-good" id="cookiesEnabled">Detecting...</span>
        </div>
      </div>
      
      <div class="info-section">
        <h3>Screen & Display</h3>
        <div class="info-item">
          <span class="info-label">Screen Size:</span>
          <span class="info-value" id="screenSize">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Viewport:</span>
          <span class="info-value" id="viewport">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Pixel Ratio:</span>
          <span class="info-value" id="pixelRatio">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Color Depth:</span>
          <span class="info-value" id="colorDepth">Detecting...</span>
        </div>
      </div>
      
      <div class="info-section">
        <h3>Browser Capabilities</h3>
        <div class="info-item">
          <span class="info-label">Local Storage:</span>
          <span class="info-value status-good" id="localStorage">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Session Storage:</span>
          <span class="info-value status-good" id="sessionStorage">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Web Workers:</span>
          <span class="info-value status-healthy" id="webWorkers">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Service Workers:</span>
          <span class="info-value status-healthy" id="serviceWorkers">Detecting...</span>
        </div>
      </div>
      
      <div class="info-section">
        <h3>Performance</h3>
        <div class="info-item">
          <span class="info-label">Connection:</span>
          <span class="info-value status-healthy" id="connection">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Memory:</span>
          <span class="info-value status-warning" id="memory">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Battery:</span>
          <span class="info-value status-good" id="battery">Detecting...</span>
        </div>
        <div class="info-item">
          <span class="info-label">Hardware Concurrency:</span>
          <span class="info-value status-healthy" id="hardwareConcurrency">Detecting...</span>
        </div>
      </div>
    </div>
    
    <div class="real-time-info">
      <h3>Real-time Updates</h3>
      <div class="real-time-grid">
        <div class="real-time-item">
          <span class="real-time-label">Current Time:</span>
          <span class="real-time-value" id="currentTime">--:--:--</span>
        </div>
        <div class="real-time-item">
          <span class="real-time-label">Page Load Time:</span>
          <span class="real-time-value" id="pageLoadTime">--</span>
        </div>
        <div class="real-time-item">
          <span class="real-time-label">Memory Usage:</span>
          <span class="real-time-value" id="memoryUsage">--</span>
        </div>
        <div class="real-time-item">
          <span class="real-time-label">FPS:</span>
          <span class="real-time-value" id="fps">--</span>
        </div>
      </div>
    </div>
    
    <div class="system-health">
      <h3>System Health Monitor</h3>
      <div class="health-grid">
        <div class="health-item">
          <span class="health-label">CPU Load:</span>
          <span class="health-value" id="cpuLoad">Calculating...</span>
          <div class="health-bar">
            <div class="health-bar-fill" id="cpuLoadBar"></div>
          </div>
        </div>
        <div class="health-item">
          <span class="health-label">Memory Health:</span>
          <span class="health-value" id="memoryHealth">Checking...</span>
          <div class="health-bar">
            <div class="health-bar-fill" id="memoryHealthBar"></div>
          </div>
        </div>
        <div class="health-item">
          <span class="health-label">Network Quality:</span>
          <span class="health-value" id="networkQuality">Testing...</span>
          <div class="health-bar">
            <div class="health-bar-fill" id="networkQualityBar"></div>
          </div>
        </div>
        <div class="health-item">
          <span class="health-label">Overall Status:</span>
          <span class="health-value" id="overallStatus">Analyzing...</span>
          <div class="health-bar">
            <div class="health-bar-fill" id="overallStatusBar"></div>
          </div>
        </div>
      </div>
    </div>
    
    
    
    <div class="toolbar center">
      <button id="btnInfoRefresh" class="chip">Refresh Info</button>
      <button id="btnRefreshIP" class="chip">Refresh IP</button>
    </div>
  </div>
</section>

<style>
  /* Info App Specific Styles - All scoped to #screen-info */
  #screen-info {
    /* Dark, modern, high-contrast theme variables (scoped) */
    --bg-0: #0b1220;
    --bg-1: #0f1a2b;
    --panel: rgba(10, 18, 33, 0.7);
    --panel-soft: rgba(255, 255, 255, 0.04);
    --text: #e6f1ff;
    --muted: #9fb3c8;
    --divider: rgba(230, 241, 255, 0.10);
    --accent: #00e5ff;   /* cyan */
    --accent-2: #ff3d00; /* orange */
    --accent-3: #39ff14; /* lime */
    --chip-bg: rgba(0, 229, 255, 0.10);
    --chip-br: rgba(0, 229, 255, 0.45);

    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    background:
      radial-gradient(800px 500px at 20% 0%, rgba(0, 229, 255, 0.08), transparent 60%),
      radial-gradient(800px 500px at 80% 100%, rgba(57, 255, 20, 0.08), transparent 60%),
      linear-gradient(180deg, var(--bg-0), var(--bg-1));
    color: var(--text);
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    padding: 0;
    overflow: hidden;
    position: fixed;
    top: 0;
    left: 0;
    margin: 0;
    border: none;
    outline: none;
    box-sizing: border-box;
    -webkit-font-smoothing: antialiased;
  }

  #screen-info * { box-sizing: border-box; }
  
  /* Home button styles */
  #screen-info .home-button {
    position: absolute;
    top: 15px;
    right: 15px;
    padding: 12px 18px;
    background: rgba(255,255,255,0.08);
    border: 1px solid var(--divider);
    border-radius: 12px;
    color: var(--text);
    font-size: 22px;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 100;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 0 0 1px rgba(0,229,255,0.25), 0 6px 20px rgba(0, 229, 255, 0.12);
  }
  
  #screen-info .home-button:hover {
    background: rgba(0,229,255,0.15);
    transform: translateY(-2px);
    box-shadow: 0 0 0 1px rgba(0,229,255,0.45), 0 10px 28px rgba(0, 229, 255, 0.18);
  }
  
  /* Matrix logo styles */
  #screen-info .matrix-logo {
    position: absolute;
    top: 15px;
    left: 15px;
    height: 40px;
    width: auto;
    z-index: 100;
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  
  #screen-info .panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    width: 100%;
    max-width: 1280px;
    margin: 0 auto;
    padding: 20px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-color: var(--accent) transparent;
  }
  
  #screen-info h2 {
    font-size: 2.2em;
    margin: 0;
    text-align: center;
    letter-spacing: 0.02em;
    text-shadow: 0 0 16px rgba(0, 229, 255, 0.18);
  }
  
  #screen-info .info-description {
    text-align: center;
    background: var(--panel-soft);
    padding: 14px 20px;
    border-radius: 12px;
    border: 1px solid var(--divider);
  }
  
  #screen-info .info-description p {
    margin: 0;
    font-size: 14px;
    color: var(--muted);
  }
  
  #screen-info .info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: 20px;
    width: 100%;
    max-width: 1200px;
  }
  
  #screen-info .info-section {
    background: var(--panel);
    border: 1px solid var(--divider);
    border-radius: 12px;
    padding: 18px;
    backdrop-filter: blur(8px);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(230, 241, 255, 0.02);
  }
  
  #screen-info .info-section h3 {
    margin: 0 0 12px 0;
    font-size: 1.05em;
    color: var(--accent);
    text-align: center;
    border-bottom: 1px solid var(--divider);
    padding-bottom: 8px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }
  
  #screen-info .info-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    padding: 8px 0;
    border-bottom: 1px dashed var(--divider);
    gap: 10px;
  }
  
  #screen-info .info-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
  }
  
  #screen-info .info-label {
    font-weight: 600;
    color: var(--muted);
    font-size: 13px;
  }
  
  #screen-info .info-value {
    background: var(--chip-bg);
    padding: 6px 10px;
    border-radius: 10px;
    border: 1px solid var(--chip-br);
    font-family: 'Courier New', monospace;
    font-size: 12px;
    max-width: 240px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    color: var(--text);
    box-shadow: inset 0 0 0 1px rgba(0,229,255,0.15);
    transition: all 0.3s ease;
  }
  
  /* Status color classes */
  #screen-info .status-good {
    color: #39ff14;
    border-color: rgba(57, 255, 20, 0.45);
    background: rgba(57, 255, 20, 0.10);
    box-shadow: inset 0 0 0 1px rgba(57, 255, 20, 0.15);
  }
  
  #screen-info .status-healthy {
    color: #00e5ff;
    border-color: rgba(0, 229, 255, 0.45);
    background: rgba(0, 229, 255, 0.10);
    box-shadow: inset 0 0 0 1px rgba(0, 229, 255, 0.15);
  }
  
  #screen-info .status-warning {
    color: #ffcc00;
    border-color: rgba(255, 204, 0, 0.45);
    background: rgba(255, 204, 0, 0.10);
    box-shadow: inset 0 0 0 1px rgba(255, 204, 0, 0.15);
  }
  
  #screen-info .status-bad {
    color: #ff3d00;
    border-color: rgba(255, 61, 0, 0.45);
    background: rgba(255, 61, 0, 0.10);
    box-shadow: inset 0 0 0 1px rgba(255, 61, 0, 0.15);
  }
  
  #screen-info .status-critical {
    color: #ff1744;
    border-color: rgba(255, 23, 68, 0.45);
    background: rgba(255, 23, 68, 0.10);
    box-shadow: inset 0 0 0 1px rgba(255, 23, 68, 0.15);
    animation: pulse-critical 2s infinite;
  }
  
  @keyframes pulse-critical {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
  }
  
  #screen-info .real-time-info {
    background: var(--panel);
    border: 1px solid var(--divider);
    border-radius: 12px;
    padding: 18px;
    width: 100%;
    max-width: 800px;
    backdrop-filter: blur(8px);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(230, 241, 255, 0.02);
  }
  
  #screen-info .real-time-info h3 {
    margin: 0 0 12px 0;
    font-size: 1.05em;
    color: var(--accent-3);
    text-align: center;
    border-bottom: 1px solid var(--divider);
    padding-bottom: 8px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }

  /* Visual metrics (gauges) */
  #screen-info .visual-metrics {
    background: var(--panel);
    border: 1px solid var(--divider);
    border-radius: 12px;
    padding: 18px;
    width: 100%;
    max-width: 1200px;
    backdrop-filter: blur(8px);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(230, 241, 255, 0.02);
  }

  #screen-info .visual-metrics h3 {
    margin: 0 0 12px 0;
    font-size: 1.05em;
    color: var(--accent-2);
    text-align: center;
    border-bottom: 1px solid var(--divider);
    padding-bottom: 8px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }

  #screen-info .gauge-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 16px;
  }

  #screen-info .gauge-card {
    position: relative;
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--divider);
    border-radius: 12px;
    padding: 8px 14px 10px 14px;
    overflow: hidden;
  }

  #screen-info .gauge-card::before {
    content: "";
    position: absolute;
    inset: 0;
    background: conic-gradient(from 0deg, var(--accent), var(--accent-2), var(--accent-3), var(--accent));
    opacity: 0.06;
    animation: spin 16s linear infinite;
    pointer-events: none;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  #screen-info .gauge-canvas {
    width: 100%;
    height: 140px;
    display: block;
    margin-top: -4px;
  }

  #screen-info .gauge-meta {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    margin-top: 8px;
  }

  #screen-info .gauge-title { color: var(--muted); font-size: 13px; }
  #screen-info .gauge-value { font-weight: 700; color: var(--text); font-family: 'Courier New', monospace; }

  /* Trends */
  #screen-info .trend-section {
    background: var(--panel);
    border: 1px solid var(--divider);
    border-radius: 12px;
    padding: 18px;
    width: 100%;
    max-width: 1200px;
    backdrop-filter: blur(8px);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(230, 241, 255, 0.02);
  }

  #screen-info .trend-section h3 {
    margin: 0 0 12px 0;
    font-size: 1.05em;
    color: var(--accent);
    text-align: center;
    border-bottom: 1px solid var(--divider);
    padding-bottom: 8px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }

  #screen-info .trend-info {
    margin-bottom: 16px;
  }
  
  #screen-info .trend-stats {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 12px;
    margin-bottom: 12px;
  }
  
  #screen-info .trend-stat {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(255,255,255,0.03);
    padding: 10px 14px;
    border-radius: 8px;
    border: 1px solid var(--divider);
  }
  
  #screen-info .trend-label {
    font-size: 13px;
    color: var(--muted);
    font-weight: 500;
  }
  
  #screen-info .trend-value {
    font-size: 14px;
    font-weight: 700;
    color: var(--accent);
    font-family: 'Courier New', monospace;
  }
  
  #screen-info .trend-canvas { width: 100%; height: 220px; display: block; }

  /* Sparklines */
  #screen-info .sparkline-section {
    background: var(--panel);
    border: 1px solid var(--divider);
    border-radius: 12px;
    padding: 18px;
    width: 100%;
    max-width: 1200px;
    backdrop-filter: blur(8px);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(230, 241, 255, 0.02);
  }

  #screen-info .sparkline-section h3 {
    margin: 0 0 12px 0;
    font-size: 1.05em;
    color: var(--accent-3);
    text-align: center;
    border-bottom: 1px solid var(--divider);
    padding-bottom: 8px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }

  #screen-info .sparkline-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 16px;
  }

  #screen-info .sparkline-card {
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--divider);
    border-radius: 12px;
    padding: 10px 12px;
  }

  #screen-info .sparkline-title { color: var(--muted); font-size: 12px; display: block; margin-bottom: 6px; }
  #screen-info .sparkline-canvas { width: 100%; height: 56px; display: block; }
  
  #screen-info .real-time-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 14px;
  }
  
  #screen-info .real-time-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    background: rgba(255,255,255,0.03);
    padding: 14px;
    border-radius: 10px;
    border: 1px solid var(--divider);
  }
  
  #screen-info .real-time-label {
    font-size: 13px;
    color: var(--muted);
    margin-bottom: 6px;
  }
  
  #screen-info .real-time-value {
    font-size: 18px;
    font-weight: 700;
    color: var(--accent-3);
    font-family: 'Courier New', monospace;
    text-shadow: 0 0 12px rgba(57,255,20,0.16);
  }
  
  /* System Health Monitor */
  #screen-info .system-health {
    background: var(--panel);
    border: 1px solid var(--divider);
    border-radius: 12px;
    padding: 18px;
    width: 100%;
    max-width: 1200px;
    backdrop-filter: blur(8px);
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 1px rgba(230, 241, 255, 0.02);
  }
  
  #screen-info .system-health h3 {
    margin: 0 0 12px 0;
    font-size: 1.05em;
    color: var(--accent-2);
    text-align: center;
    border-bottom: 1px solid var(--divider);
    padding-bottom: 8px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }
  
  #screen-info .health-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 16px;
  }
  
  #screen-info .health-item {
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--divider);
    border-radius: 10px;
    padding: 14px;
    position: relative;
    overflow: hidden;
  }
  
  #screen-info .health-item::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, #39ff14, #00e5ff, #ffcc00, #ff3d00);
    opacity: 0.6;
  }
  
  #screen-info .health-label {
    display: block;
    font-size: 13px;
    color: var(--muted);
    margin-bottom: 6px;
  }
  
  #screen-info .health-value {
    display: block;
    font-size: 16px;
    font-weight: 700;
    color: var(--text);
    font-family: 'Courier New', monospace;
    margin-bottom: 8px;
  }
  
  #screen-info .health-bar {
    width: 100%;
    height: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 3px;
    overflow: hidden;
    position: relative;
  }
  
  #screen-info .health-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #39ff14, #00e5ff);
    border-radius: 3px;
    transition: width 0.5s ease, background 0.3s ease;
    position: relative;
  }
  
  #screen-info .health-bar-fill::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 2s infinite;
  }
  
  @keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }
  
  #screen-info .toolbar {
    display: flex;
    gap: 12px;
    margin: 10px 0 0 0;
    flex-wrap: wrap;
    justify-content: center;
  }
  
  #screen-info .chip {
    padding: 12px 22px;
    border: 1px solid var(--chip-br);
    border-radius: 12px;
    background: var(--chip-bg);
    color: var(--text);
    font-size: 15px;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: inherit;
    box-shadow: 0 0 0 1px rgba(0,229,255,0.18), 0 8px 24px rgba(0, 229, 255, 0.14);
  }
  
  #screen-info .chip:hover {
    background: rgba(0,229,255,0.18);
    border-color: rgba(0,229,255,0.6);
    transform: translateY(-2px);
    box-shadow: 0 0 0 1px rgba(0,229,255,0.4), 0 12px 32px rgba(0, 229, 255, 0.18);
  }

  /* Scoped custom scrollbars for panel */
  #screen-info .panel::-webkit-scrollbar { 
    width: 10px; 
    height: 10px; 
  }
  #screen-info .panel::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, var(--accent), var(--accent-2));
    border-radius: 10px;
  }
  #screen-info .panel::-webkit-scrollbar-track { 
    background: transparent; 
  }
  
  /* Hide default scrollbar for other browsers */
  #screen-info .panel {
    scrollbar-width: thin;
    scrollbar-color: var(--accent) transparent;
  }
  
  /* 5-inch touchscreen optimization (800x480) */
  @media (max-width: 850px) and (max-height: 500px) {
    #screen-info {
      padding: 0;
    }
    
    #screen-info .panel {
      padding: 8px;
      gap: 8px;
    }
    
    #screen-info .matrix-logo {
      height: 25px;
      top: 6px;
      left: 6px;
    }
    
    #screen-info .home-button {
      top: 6px;
      right: 6px;
      width: 28px;
      height: 28px;
      font-size: 12px;
    }
    
    #screen-info h2 {
      font-size: 1.3em;
      margin: 3px 0;
    }
    
    #screen-info .info-grid {
      grid-template-columns: 1fr;
      gap: 8px;
    }
    
    #screen-info .info-section {
      padding: 8px;
    }
    
    #screen-info .info-item {
      margin-bottom: 6px;
      padding: 4px 0;
    }
    
    #screen-info .info-label {
      font-size: 11px;
    }
    
    #screen-info .info-value {
      font-size: 10px;
      padding: 4px 6px;
    }
    
    #screen-info .real-time-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    
    #screen-info .trend-stats {
      grid-template-columns: repeat(2, 1fr);
      gap: 6px;
    }
    
    #screen-info .chip {
      padding: 6px 12px;
      font-size: 12px;
    }
  }

  /* Responsive design */
  @media (max-width: 1024px) {
    #screen-info .panel { padding-top: 12px; }
  }

  @media (max-width: 768px) {
    #screen-info h2 { font-size: 1.8em; }
    #screen-info .info-grid {
      grid-template-columns: 1fr;
      gap: 16px;
    }
    #screen-info .info-section { padding: 14px; }
    #screen-info .info-item {
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
    }
    #screen-info .info-value {
      max-width: 100%;
      text-align: left;
    }
    #screen-info .real-time-grid {
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    #screen-info .trend-stats {
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }
    #screen-info .chip { padding: 10px 18px; font-size: 14px; }
  }

  @media (max-width: 480px) {
    #screen-info h2 { font-size: 1.6em; }
    #screen-info .matrix-logo { height: 32px; }
    #screen-info .info-value {
      white-space: normal;         /* allow wrapping on very small screens */
      word-break: break-word;
    }
    #screen-info .real-time-grid { grid-template-columns: 1fr; }
    #screen-info .trend-stats { grid-template-columns: 1fr; }
  }

  /* Hide mouse cursor on small touchscreen devices (5-inch screens) */
  @media (max-width: 800px) and (max-height: 600px) {
    #screen-info {
      cursor: none;
    }
    #screen-info * {
      cursor: none !important;
    }
  }

  /* Hide cursor on touch-only devices */
  @media (hover: none) and (pointer: coarse) {
    #screen-info {
      cursor: none;
    }
    #screen-info * {
      cursor: none !important;
    }
  }

  /* Keep cursor visible on desktop devices */
  @media (hover: hover) and (pointer: fine) and (min-width: 1200px) {
    #screen-info {
      cursor: auto;
    }
    #screen-info * {
      cursor: auto !important;
    }
  }
</style>

<script>
  (function() {
    'use strict';
    
    // App state
    let updateTimer = null;
    let fpsCounter = 0;
    let lastFpsTime = 0;
    let pageLoadStart = performance.now();
    let lastComputedFPS = 0;
    let maxHistoryPoints = 120;
    let history = { fps: [], mem: [], net: [] };
    let batteryState = { level: null, charging: null };
    let netDownlinkMbps = null;
    let ipAddress = null;
    let networkLatency = null;
    let cpuLoadHistory = [];
    let healthUpdateTimer = null;
    let appStartTime = Date.now();
    let peakFPS = 0;
    let totalMemorySamples = 0;
    let totalMemorySum = 0;
    
    // DOM elements
    let elements = {};
    
    function initApp() {
      console.log('System Info app initialized');
      setupDOM();
      initCanvases();
      setupEventListeners();
      collectSystemInfo();
      startRealTimeUpdates();
    }
    
    function setupDOM() {
      // Device Information
      elements.platform = document.querySelector('#platform');
      elements.userAgent = document.querySelector('#userAgent');
      elements.language = document.querySelector('#language');
      elements.cookiesEnabled = document.querySelector('#cookiesEnabled');
      
      // Screen & Display
      elements.screenSize = document.querySelector('#screenSize');
      elements.viewport = document.querySelector('#viewport');
      elements.pixelRatio = document.querySelector('#pixelRatio');
      elements.colorDepth = document.querySelector('#colorDepth');
      
      // Browser Capabilities
      elements.localStorage = document.querySelector('#localStorage');
      elements.sessionStorage = document.querySelector('#sessionStorage');
      elements.webWorkers = document.querySelector('#webWorkers');
      elements.serviceWorkers = document.querySelector('#serviceWorkers');
      
      // Performance
      elements.connection = document.querySelector('#connection');
      elements.memory = document.querySelector('#memory');
      elements.battery = document.querySelector('#battery');
      elements.hardwareConcurrency = document.querySelector('#hardwareConcurrency');
      
      // Real-time
      elements.currentTime = document.querySelector('#currentTime');
      elements.pageLoadTime = document.querySelector('#pageLoadTime');
      elements.memoryUsage = document.querySelector('#memoryUsage');
      elements.fps = document.querySelector('#fps');

      // Gauges
      elements.gaugeActivityCanvas = document.querySelector('#gaugeActivity');
      elements.gaugeMemoryCanvas = document.querySelector('#gaugeMemory');
      elements.gaugeBatteryCanvas = document.querySelector('#gaugeBattery');
      elements.gaugeNetworkCanvas = document.querySelector('#gaugeNetwork');
      elements.gaugeActivityValue = document.querySelector('#gaugeActivityValue');
      elements.gaugeMemoryValue = document.querySelector('#gaugeMemoryValue');
      elements.gaugeBatteryValue = document.querySelector('#gaugeBatteryValue');
      elements.gaugeNetworkValue = document.querySelector('#gaugeNetworkValue');

      // Trend and sparklines
      elements.trendCanvas = document.querySelector('#trendCanvas');
      elements.sparkFPSCanvas = document.querySelector('#sparkFPS');
      elements.sparkMemCanvas = document.querySelector('#sparkMem');
      elements.sparkNetCanvas = document.querySelector('#sparkNet');
      
      // Network and Health elements
      elements.ipAddress = document.querySelector('#ipAddress');
      elements.networkStatus = document.querySelector('#networkStatus');
      elements.connectionType = document.querySelector('#connectionType');
      elements.latency = document.querySelector('#latency');
      
      // Health monitor elements
      elements.cpuLoad = document.querySelector('#cpuLoad');
      elements.memoryHealth = document.querySelector('#memoryHealth');
      elements.networkQuality = document.querySelector('#networkQuality');
      elements.overallStatus = document.querySelector('#overallStatus');
      elements.cpuLoadBar = document.querySelector('#cpuLoadBar');
      elements.memoryHealthBar = document.querySelector('#memoryHealthBar');
      elements.networkQualityBar = document.querySelector('#networkQualityBar');
      elements.overallStatusBar = document.querySelector('#overallStatusBar');
      
      // Trend statistics elements
      elements.peakFPS = document.querySelector('#peakFPS');
      elements.avgMemory = document.querySelector('#avgMemory');
      elements.networkSpeed = document.querySelector('#networkSpeed');
      elements.uptime = document.querySelector('#uptime');
    }
    
    function setupEventListeners() {
      const container = document.querySelector('#screen-info');
      
      container.addEventListener('click', function(e) {
        if (e.target.id === 'btnInfoRefresh') {
          collectSystemInfo();
        } else if (e.target.id === 'btnRefreshIP') {
          detectIPAddress();
        } else if (e.target.id === 'btnHome') {
          goHome();
        }
      });
      window.addEventListener('resize', debounce(function() {
        initCanvases();
        redrawAllCharts();
      }, 150));
    }
    
    function collectSystemInfo() {
      // Device Information
      elements.platform.textContent = navigator.platform || 'Unknown';
      elements.userAgent.textContent = navigator.userAgent.substring(0, 50) + '...';
      elements.language.textContent = navigator.language || 'Unknown';
      elements.cookiesEnabled.textContent = navigator.cookieEnabled ? 'Yes' : 'No';
      
      // Screen & Display
      elements.screenSize.textContent = `${screen.width} √ó ${screen.height}`;
      elements.viewport.textContent = `${window.innerWidth} √ó ${window.innerHeight}`;
      elements.pixelRatio.textContent = window.devicePixelRatio || '1';
      elements.colorDepth.textContent = `${screen.colorDepth} bit`;
      
      // Browser Capabilities
      elements.localStorage.textContent = testLocalStorage() ? 'Yes' : 'No';
      elements.sessionStorage.textContent = testSessionStorage() ? 'Yes' : 'No';
      elements.webWorkers.textContent = typeof Worker !== 'undefined' ? 'Yes' : 'No';
      elements.serviceWorkers.textContent = 'serviceWorker' in navigator ? 'Yes' : 'No';
      
      // Performance
      elements.connection.textContent = getConnectionInfo();
      elements.memory.textContent = getMemoryInfo();
      elements.battery.textContent = 'Checking...';
      elements.hardwareConcurrency.textContent = navigator.hardwareConcurrency || 'Unknown';
      
      // Network Information
      detectIPAddress();
      testNetworkLatency();
      updateNetworkStatus();
      
      // Check battery if available
      checkBattery();
      
      // Check connection if available
      checkConnection();
      
      // Start health monitoring
      startHealthMonitoring();
    }
    
    function testLocalStorage() {
      try {
        const test = 'test';
        localStorage.setItem(test, test);
        localStorage.removeItem(test);
        return true;
      } catch (e) {
        return false;
      }
    }
    
    function testSessionStorage() {
      try {
        const test = 'test';
        sessionStorage.setItem(test, test);
        sessionStorage.removeItem(test);
        return true;
      } catch (e) {
        return false;
      }
    }
    
    function getConnectionInfo() {
      if ('connection' in navigator) {
        const conn = navigator.connection;
        return `${conn.effectiveType || 'Unknown'} (${conn.downlink || 'Unknown'} Mbps)`;
      }
      return 'Not available';
    }
    
    function getMemoryInfo() {
      if ('memory' in performance) {
        const mem = performance.memory;
        const used = Math.round(mem.usedJSHeapSize / 1048576);
        const total = Math.round(mem.totalJSHeapSize / 1048576);
        return `${used}MB / ${total}MB`;
      }
      return 'Not available';
    }
    
    function checkBattery() {
      if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
          const level = Math.round(battery.level * 100);
          const charging = battery.charging ? ' (Charging)' : '';
          elements.battery.textContent = `${level}%${charging}`;
          // Track for gauges
          if (typeof battery.level === 'number') batteryState.level = battery.level;
          if (typeof battery.charging === 'boolean') batteryState.charging = battery.charging;

          battery.addEventListener('levelchange', function() {
            batteryState.level = battery.level;
          });
          battery.addEventListener('chargingchange', function() {
            batteryState.charging = battery.charging;
          });
        }).catch(() => {
          elements.battery.textContent = 'Not available';
        });
      } else {
        elements.battery.textContent = 'Not available';
      }
    }
    
    function checkConnection() {
      if ('connection' in navigator) {
        navigator.connection.addEventListener('change', () => {
          elements.connection.textContent = getConnectionInfo();
          if (typeof navigator.connection.downlink === 'number') {
            netDownlinkMbps = navigator.connection.downlink;
          }
        });
        if (typeof navigator.connection.downlink === 'number') {
          netDownlinkMbps = navigator.connection.downlink;
        }
      }
    }
    
    // IP Address Detection
    function detectIPAddress() {
      elements.ipAddress.textContent = 'Detecting...';
      elements.ipAddress.className = 'info-value status-warning';
      
      // Try multiple reliable IP detection services with better error handling
      const ipServices = [
        {
          url: 'https://api.ipify.org?format=json',
          extract: (data) => data.ip
        },
        {
          url: 'https://api64.ipify.org?format=json',
          extract: (data) => data.ip
        },
        {
          url: 'https://httpbin.org/ip',
          extract: (data) => data.origin
        },
        {
          url: 'https://api.myip.com',
          extract: (data) => data.ip
        }
      ];
      
      // Try each service with timeout
      let attempts = 0;
      const maxAttempts = ipServices.length;
      
      function tryNextService() {
        if (attempts >= maxAttempts) {
          // All services failed, try local detection
          getLocalIPAddress();
          return;
        }
        
        const service = ipServices[attempts];
        attempts++;
        
        // Create a timeout promise
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Timeout')), 3000);
        });
        
        // Try the service with timeout
        Promise.race([
          fetch(service.url, { 
            method: 'GET',
            cache: 'no-cache',
            headers: { 'Accept': 'application/json' }
          }).then(r => {
            if (!r.ok) throw new Error('Network response was not ok');
            return r.json();
          }),
          timeoutPromise
        ]).then(data => {
          const ip = service.extract(data);
          if (ip && isValidIP(ip)) {
            ipAddress = ip;
            elements.ipAddress.textContent = ipAddress;
            elements.ipAddress.className = 'info-value status-good';
            console.log('IP detected successfully:', ipAddress);
          } else {
            throw new Error('Invalid IP format');
          }
        }).catch(error => {
          console.log(`IP service ${attempts} failed:`, error.message);
          // Try next service
          setTimeout(tryNextService, 500);
        });
      }
      
      tryNextService();
    }
    
    function isValidIP(ip) {
      // Basic IP validation
      const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
      const ipv6Regex = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
      return ipv4Regex.test(ip) || ipv6Regex.test(ip);
    }
    
    function getLocalIPAddress() {
      console.log('Attempting local IP detection...');
      
      // Method 1: Try WebRTC (more reliable approach)
      const RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;
      
      if (RTCPeerConnection) {
        try {
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceCandidatePoolSize: 1
          });
          
          pc.createDataChannel('');
          pc.createOffer()
            .then(offer => pc.setLocalDescription(offer))
            .catch(() => {
              elements.ipAddress.textContent = 'Detection Failed';
              elements.ipAddress.className = 'info-value status-bad';
            });
          
          pc.onicecandidate = (event) => {
            if (event.candidate) {
              const candidate = event.candidate.candidate;
              const ipMatch = candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
              
              if (ipMatch && isValidIP(ipMatch[1])) {
                const localIP = ipMatch[1];
                // Filter out common local IPs that aren't useful
                if (!localIP.startsWith('192.168.') && 
                    !localIP.startsWith('10.') && 
                    !localIP.startsWith('172.') &&
                    localIP !== '127.0.0.1') {
                  ipAddress = localIP;
                  elements.ipAddress.textContent = `Local: ${ipAddress}`;
                  elements.ipAddress.className = 'info-value status-healthy';
                  console.log('Local IP detected:', ipAddress);
                } else {
                  elements.ipAddress.textContent = 'Local Network';
                  elements.ipAddress.className = 'info-value status-healthy';
                }
                pc.close();
              }
            }
          };
          
          // Timeout after 2 seconds
          setTimeout(() => {
            if (!ipAddress) {
              elements.ipAddress.textContent = 'Network Only';
              elements.ipAddress.className = 'info-value status-warning';
            }
            pc.close();
          }, 2000);
          
        } catch (error) {
          console.log('WebRTC failed:', error);
          elements.ipAddress.textContent = 'Not Available';
          elements.ipAddress.className = 'info-value status-bad';
        }
      } else {
        elements.ipAddress.textContent = 'Not Supported';
        elements.ipAddress.className = 'info-value status-bad';
      }
    }
    
    // Network Latency Testing
    function testNetworkLatency() {
      const startTime = performance.now();
      fetch('https://httpbin.org/delay/0', { 
        method: 'HEAD',
        cache: 'no-cache'
      }).then(() => {
        const endTime = performance.now();
        networkLatency = Math.round(endTime - startTime);
        elements.latency.textContent = `${networkLatency}ms`;
        updateLatencyStatus(networkLatency);
      }).catch(() => {
        elements.latency.textContent = 'Failed';
        elements.latency.className = 'info-value status-bad';
      });
    }
    
    function updateLatencyStatus(latency) {
      if (latency < 50) {
        elements.latency.className = 'info-value status-good';
      } else if (latency < 100) {
        elements.latency.className = 'info-value status-healthy';
      } else if (latency < 200) {
        elements.latency.className = 'info-value status-warning';
      } else {
        elements.latency.className = 'info-value status-bad';
      }
    }
    
    // Network Status Update
    function updateNetworkStatus() {
      if ('connection' in navigator) {
        const conn = navigator.connection;
        const effectiveType = conn.effectiveType || 'Unknown';
        const downlink = conn.downlink || 0;
        
        elements.connectionType.textContent = `${effectiveType} (${downlink} Mbps)`;
        
        if (effectiveType === '4g' || downlink > 10) {
          elements.networkStatus.textContent = 'Excellent';
          elements.networkStatus.className = 'info-value status-good';
        } else if (effectiveType === '3g' || downlink > 5) {
          elements.networkStatus.textContent = 'Good';
          elements.networkStatus.className = 'info-value status-healthy';
        } else if (effectiveType === '2g' || downlink > 1) {
          elements.networkStatus.textContent = 'Fair';
          elements.networkStatus.className = 'info-value status-warning';
        } else {
          elements.networkStatus.textContent = 'Poor';
          elements.networkStatus.className = 'info-value status-bad';
        }
      } else {
        elements.connectionType.textContent = 'Not Available';
        elements.networkStatus.textContent = 'Unknown';
        elements.networkStatus.className = 'info-value status-warning';
      }
    }
    
    // Health Monitoring System
    function startHealthMonitoring() {
      healthUpdateTimer = setInterval(updateHealthMetrics, 2000);
    }
    
    function updateHealthMetrics() {
      // CPU Load (simulated based on FPS and memory usage)
      const cpuLoad = calculateCPULoad();
      updateHealthBar('cpuLoad', cpuLoad, 'CPU Load', '%');
      
      // Memory Health
      const memoryHealth = calculateMemoryHealth();
      updateHealthBar('memoryHealth', memoryHealth, 'Memory Health', '%');
      
      // Network Quality
      const networkQuality = calculateNetworkQuality();
      updateHealthBar('networkQuality', networkQuality, 'Network Quality', '%');
      
      // Overall Status
      const overallStatus = Math.round((cpuLoad + memoryHealth + networkQuality) / 3);
      updateHealthBar('overallStatus', overallStatus, 'Overall Status', '%');
    }
    
    function calculateCPULoad() {
      // Simulate CPU load based on FPS and system activity
      const fpsFactor = Math.max(0, 100 - (lastComputedFPS / 60) * 100);
      const memoryFactor = history.mem.length > 0 ? 
        Math.min(100, (history.mem[history.mem.length - 1] / 1000) * 100) : 50;
      
      return Math.round((fpsFactor * 0.6) + (memoryFactor * 0.4));
    }
    
    function calculateMemoryHealth() {
      if ('memory' in performance) {
        const mem = performance.memory;
        const usedPercent = (mem.usedJSHeapSize / mem.totalJSHeapSize) * 100;
        return Math.round(Math.max(0, 100 - usedPercent));
      }
      return 75; // Fallback value
    }
    
    function calculateNetworkQuality() {
      if (networkLatency && networkLatency > 0) {
        if (networkLatency < 50) return 95;
        if (networkLatency < 100) return 85;
        if (networkLatency < 200) return 70;
        if (networkLatency < 500) return 50;
        return 30;
      }
      return 80; // Fallback value
    }
    
    function updateTrendStats() {
      // Update peak FPS
      if (lastComputedFPS > peakFPS) {
        peakFPS = lastComputedFPS;
      }
      if (elements.peakFPS) {
        elements.peakFPS.textContent = `${peakFPS} FPS`;
      }
      
      // Update average memory
      if ('memory' in performance) {
        const mem = performance.memory;
        const currentMem = mem.usedJSHeapSize / 1048576;
        totalMemorySamples++;
        totalMemorySum += currentMem;
        const avgMem = Math.round(totalMemorySum / totalMemorySamples);
        if (elements.avgMemory) {
          elements.avgMemory.textContent = `${avgMem} MB`;
        }
      }
      
      // Update network speed
      const currentNetSpeed = getDownlinkMbps();
      if (elements.networkSpeed) {
        elements.networkSpeed.textContent = `${currentNetSpeed.toFixed(1)} Mbps`;
      }
      
      // Update uptime
      const uptimeMs = Date.now() - appStartTime;
      const uptimeSeconds = Math.floor(uptimeMs / 1000);
      const hours = Math.floor(uptimeSeconds / 3600);
      const minutes = Math.floor((uptimeSeconds % 3600) / 60);
      const seconds = uptimeSeconds % 60;
      
      let uptimeText = '';
      if (hours > 0) {
        uptimeText = `${hours}h ${minutes}m ${seconds}s`;
      } else if (minutes > 0) {
        uptimeText = `${minutes}m ${seconds}s`;
      } else {
        uptimeText = `${seconds}s`;
      }
      
      if (elements.uptime) {
        elements.uptime.textContent = uptimeText;
      }
    }
    
    function updateHealthBar(type, value, label, unit) {
      const element = elements[type];
      const barElement = elements[`${type}Bar`];
      
      if (element && barElement) {
        element.textContent = `${label}: ${value}${unit}`;
        barElement.style.width = `${value}%`;
        
        // Update bar color based on value
        if (value >= 80) {
          barElement.style.background = 'linear-gradient(90deg, #39ff14, #00e5ff)';
        } else if (value >= 60) {
          barElement.style.background = 'linear-gradient(90deg, #00e5ff, #ffcc00)';
        } else if (value >= 40) {
          barElement.style.background = 'linear-gradient(90deg, #ffcc00, #ff3d00)';
        } else {
          barElement.style.background = 'linear-gradient(90deg, #ff3d00, #ff1744)';
        }
      }
    }
    
    function startRealTimeUpdates() {
      updateTimer = setInterval(updateRealTimeInfo, 1000);
      
      // FPS counter
      let lastTime = performance.now();
      function countFPS() {
        const currentTime = performance.now();
        fpsCounter++;
        
        if (currentTime - lastTime >= 1000) {
          const fps = Math.round((fpsCounter * 1000) / (currentTime - lastTime));
          lastComputedFPS = fps;
          elements.fps.textContent = `${fps} FPS`;
          fpsCounter = 0;
          lastTime = currentTime;
        }
        
        requestAnimationFrame(countFPS);
      }
      countFPS();
    }
    
    function updateRealTimeInfo() {
      // Current time
      const now = new Date();
      elements.currentTime.textContent = now.toLocaleTimeString();
      
      // Page load time
      const loadTime = Math.round(performance.now() - pageLoadStart);
      elements.pageLoadTime.textContent = `${loadTime}ms`;
      
      // Memory usage
      if ('memory' in performance) {
        const mem = performance.memory;
        const used = Math.round(mem.usedJSHeapSize / 1048576);
        elements.memoryUsage.textContent = `${used}MB`;
      }

      // Gather numeric metrics
      const fpsVal = clamp(lastComputedFPS, 0, 120);
      const memStats = getMemoryStats();
      const netMbps = getDownlinkMbps();
      const batteryPct = getBatteryPercent();

      // Update histories
      pushTrim(history.fps, fpsVal, maxHistoryPoints);
      pushTrim(history.mem, memStats.usedMB, maxHistoryPoints);
      pushTrim(history.net, netMbps, maxHistoryPoints);

      // Compute activity index (0-100)
      const fpsNorm = clamp(fpsVal / 60, 0, 1);
      const netNorm = clamp(netMbps / 10, 0, 1); // assume 10 Mbps as 100%
      const memNorm = memStats.totalMB > 0 ? clamp(memStats.usedMB / Math.max(memStats.totalMB, 1), 0, 1) : 0.4;
      const activity = Math.round(((fpsNorm * 0.5) + (netNorm * 0.3) + (memNorm * 0.2)) * 100);

      // Update gauge labels
      if (elements.gaugeActivityValue) elements.gaugeActivityValue.textContent = `${activity}%`;
      if (elements.gaugeMemoryValue) elements.gaugeMemoryValue.textContent = memStats.totalMB > 0 ? `${Math.round(memStats.usedMB)}/${Math.round(memStats.totalMB)} MB` : `${Math.round(memStats.usedMB)} MB`;
      if (elements.gaugeBatteryValue) elements.gaugeBatteryValue.textContent = batteryPct >= 0 ? `${batteryPct}%${batteryState.charging ? ' ‚ö°' : ''}` : 'N/A';
      if (elements.gaugeNetworkValue) elements.gaugeNetworkValue.textContent = `${netMbps.toFixed(1)} Mbps`;

      // Draw gauges
      drawGauge(elements.gaugeActivityCanvas, activity, ['#00e5ff', '#ff3d00']);
      const memPercent = memStats.totalMB > 0 ? clamp((memStats.usedMB / memStats.totalMB) * 100, 0, 100) : clamp(memStats.usedMB / 2000 * 100, 0, 100);
      drawGauge(elements.gaugeMemoryCanvas, memPercent, ['#ff3d00', '#ffcc00']);
      drawGauge(elements.gaugeBatteryCanvas, batteryPct >= 0 ? batteryPct : 0, ['#39ff14', '#00e5ff']);
      const netPercent = clamp((netMbps / 10) * 100, 0, 100);
      drawGauge(elements.gaugeNetworkCanvas, netPercent, ['#00e5ff', '#39ff14']);

      // Update trend statistics
      updateTrendStats();
      
      // Draw trend and sparklines
      drawTrend(elements.trendCanvas, history);
      drawSparkline(elements.sparkFPSCanvas, history.fps, '#00e5ff');
      drawSparkline(elements.sparkMemCanvas, history.mem, '#ff3d00');
      drawSparkline(elements.sparkNetCanvas, history.net, '#39ff14');
    }
    
    function goHome() {
      // Direct navigation back to home
      window.location.href = '../index.html';
    }

    /* Helpers */
    function debounce(fn, delay) {
      let t = null;
      return function() {
        if (t) clearTimeout(t);
        t = setTimeout(fn, delay);
      };
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function pushTrim(arr, value, maxLen) {
      arr.push(value);
      if (arr.length > maxLen) arr.shift();
    }

    function getDownlinkMbps() {
      if ('connection' in navigator && navigator.connection && typeof navigator.connection.downlink === 'number') {
        netDownlinkMbps = navigator.connection.downlink || netDownlinkMbps || 0;
      }
      if (typeof netDownlinkMbps !== 'number' || isNaN(netDownlinkMbps)) {
        // fallback: gentle pseudo-random walk
        netDownlinkMbps = (netDownlinkMbps || 2) + ((Math.random() - 0.5) * 0.6);
      }
      return clamp(netDownlinkMbps, 0, 50);
    }

    function getMemoryStats() {
      if ('memory' in performance) {
        const mem = performance.memory;
        return {
          usedMB: mem.usedJSHeapSize / 1048576,
          totalMB: mem.totalJSHeapSize / 1048576
        };
      }
      // fallback: synthetic usage with smoothing
      const prev = history.mem.length ? history.mem[history.mem.length - 1] : 400;
      const next = clamp(prev + (Math.random() - 0.5) * 20, 200, 800);
      return { usedMB: next, totalMB: 0 };
    }

    function getBatteryPercent() {
      if (batteryState.level == null) return -1;
      return clamp(Math.round(batteryState.level * 100), 0, 100);
    }

    function initCanvases() {
      [elements.gaugeActivityCanvas, elements.gaugeMemoryCanvas, elements.gaugeBatteryCanvas, elements.gaugeNetworkCanvas, elements.trendCanvas, elements.sparkFPSCanvas, elements.sparkMemCanvas, elements.sparkNetCanvas]
        .forEach(function(c){ if (c) sizeCanvasForDPR(c); });
    }

    function sizeCanvasForDPR(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(1, Math.round(rect.width * dpr));
      canvas.height = Math.max(1, Math.round(rect.height * dpr));
      const ctx = canvas.getContext('2d');
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
      return ctx;
    }

    function redrawAllCharts() {
      // Redraw using latest history
      const fpsVal = history.fps.length ? history.fps[history.fps.length - 1] : 0;
      const memStats = getMemoryStats();
      const netMbps = getDownlinkMbps();
      const batteryPct = getBatteryPercent();
      const fpsNorm = clamp(fpsVal / 60, 0, 1);
      const netNorm = clamp(netMbps / 10, 0, 1);
      const memNorm = memStats.totalMB > 0 ? clamp(memStats.usedMB / Math.max(memStats.totalMB, 1), 0, 1) : 0.4;
      const activity = Math.round(((fpsNorm * 0.5) + (netNorm * 0.3) + (memNorm * 0.2)) * 100);

      drawGauge(elements.gaugeActivityCanvas, activity, ['#00e5ff', '#ff3d00']);
      const memPercent = memStats.totalMB > 0 ? clamp((memStats.usedMB / memStats.totalMB) * 100, 0, 100) : clamp(memStats.usedMB / 2000 * 100, 0, 100);
      drawGauge(elements.gaugeMemoryCanvas, memPercent, ['#ff3d00', '#ffcc00']);
      drawGauge(elements.gaugeBatteryCanvas, batteryPct >= 0 ? batteryPct : 0, ['#39ff14', '#00e5ff']);
      const netPercent = clamp((netMbps / 10) * 100, 0, 100);
      drawGauge(elements.gaugeNetworkCanvas, netPercent, ['#00e5ff', '#39ff14']);

      drawTrend(elements.trendCanvas, history);
      drawSparkline(elements.sparkFPSCanvas, history.fps, '#00e5ff');
      drawSparkline(elements.sparkMemCanvas, history.mem, '#ff3d00');
      drawSparkline(elements.sparkNetCanvas, history.net, '#39ff14');
    }

    /* Drawing functions */
    function drawGauge(canvas, percent, colors) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      ctx.clearRect(0, 0, w, h);

      const cx = w / 2;
      const cy = h * 0.9;
      const radius = Math.min(w, h * 1.1) * 0.42;
      const start = Math.PI;      // 180¬∞
      const endBg = 2 * Math.PI; // 360¬∞

      // background arc
      ctx.beginPath();
      ctx.arc(cx, cy, radius, start, endBg);
      ctx.strokeStyle = 'rgba(230,241,255,0.12)';
      ctx.lineWidth = 10;
      ctx.lineCap = 'round';
      ctx.stroke();

      // value arc
      const endVal = start + (percent / 100) * Math.PI;
      const grad = ctx.createLinearGradient(cx - radius, cy, cx + radius, cy);
      grad.addColorStop(0, colors[0]);
      grad.addColorStop(1, colors[1]);
      ctx.beginPath();
      ctx.arc(cx, cy, radius, start, endVal);
      ctx.strokeStyle = grad;
      ctx.lineWidth = 12;
      ctx.shadowColor = colors[0];
      ctx.shadowBlur = 6;
      ctx.stroke();

      // ticks
      ctx.save();
      ctx.translate(cx, cy);
      for (let i = 0; i <= 10; i++) {
        const ang = Math.PI + (i / 10) * Math.PI;
        const x1 = Math.cos(ang) * (radius + 2);
        const y1 = Math.sin(ang) * (radius + 2);
        const x2 = Math.cos(ang) * (radius + 10);
        const y2 = Math.sin(ang) * (radius + 10);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = 'rgba(230,241,255,0.12)';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawTrend(canvas, hist) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      ctx.clearRect(0, 0, w, h);

      // axes (minimal)
      ctx.strokeStyle = 'rgba(230,241,255,0.10)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(32, h - 24);
      ctx.lineTo(w - 8, h - 24);
      ctx.moveTo(32, 8);
      ctx.lineTo(32, h - 24);
      ctx.stroke();

      // scale functions
      const left = 36, right = w - 10;
      const top = 14, bottom = h - 28;
      const maxLen = Math.max(hist.fps.length, hist.mem.length, hist.net.length, 1);
      function xFor(i) {
        return left + (i / Math.max(maxLen - 1, 1)) * (right - left);
      }

      // y scales (separate domains)
      const fpsMax = 60;
      const memMax = Math.max(800, Math.max.apply(null, hist.mem.concat([0])));
      const netMax = Math.max(10, Math.max.apply(null, hist.net.concat([0])));
      function yFor(val, maxV) { return bottom - (clamp(val / maxV, 0, 1) * (bottom - top)); }

      // line renderer
      function drawLine(data, color, maxV) {
        if (!data.length) return;
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = color;
        data.forEach(function(v, i){
          const x = xFor(i);
          const y = yFor(v, maxV);
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.shadowColor = color;
        ctx.shadowBlur = 6;
        ctx.stroke();
      }

      drawLine(hist.fps, '#00e5ff', fpsMax);
      drawLine(hist.mem, '#ff3d00', memMax);
      drawLine(hist.net, '#39ff14', netMax);
    }

    function drawSparkline(canvas, data, color) {
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;
      ctx.clearRect(0, 0, w, h);
      if (!data.length) return;
      const left = 2, right = w - 2, top = 2, bottom = h - 2;
      const maxVal = Math.max.apply(null, data.concat([1]));
      const minVal = Math.min.apply(null, data.concat([0]));
      function xFor(i) { return left + (i / Math.max(data.length - 1, 1)) * (right - left); }
      function yFor(v) {
        const range = Math.max(maxVal - minVal, 1);
        return bottom - ((v - minVal) / range) * (bottom - top);
      }
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = color;
      data.forEach(function(v, i){ const x = xFor(i), y = yFor(v); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
      ctx.shadowColor = color;
      ctx.shadowBlur = 6;
      ctx.stroke();
    }
    
    // Lifecycle management
    window.appLifecycle = {
      activate: function() {
        console.log('System Info app activated');
        // Resume real-time updates
        if (!updateTimer) {
          startRealTimeUpdates();
        }
      },
      
      deactivate: function() {
        console.log('System Info app deactivated');
        // Pause real-time updates when switching away
        if (updateTimer) {
          clearInterval(updateTimer);
          updateTimer = null;
        }
      },
      
      cleanup: function() {
        console.log('System Info app cleanup');
        // Stop real-time updates
        if (updateTimer) {
          clearInterval(updateTimer);
          updateTimer = null;
        }
        // Stop health monitoring
        if (healthUpdateTimer) {
          clearInterval(healthUpdateTimer);
          healthUpdateTimer = null;
        }
      }
    };
    
    // Initialize app
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  })();
</script>
